{"version":3,"sources":["webpack:///./src/js/AvaNetwork.ts","webpack:///./src/js/TxHelper.ts","webpack:///./src/js/Crypto.ts","webpack:///./src/js/Keystore.ts","webpack:///./src/explorer_api.ts","webpack:///./src/evm.ts","webpack:///./src/helpers/wallet_helper.ts","webpack:///./src/js/HdHelper.ts","webpack:///./src/js/wallets/HdWalletCore.ts","webpack:///./src/helpers/history_helper.ts","webpack:///./src/js/wallets/LedgerWallet.ts","webpack:///./src/locales/lang_map.js","webpack:///./src/js/wallets/SingletonWallet.ts","webpack:///./src/js/AvaNftFamily.ts","webpack:///./src/helpers/helper.ts","webpack:///./src/js/AvaAsset.ts","webpack:///./src/js/wallets/AvaHdWallet.ts"],"names":["network_id","name","url","networkId","explorerUrl","explorerSiteUrl","readonly","this","id","protocol","port","ip","updateURL","split","includes","urlSplit","parseInt","getFullURL","AvmTxNameEnum","PlatfromTxNameEnum","ParseableAvmTxEnum","ParseablePlatformEnum","buildUnsignedTransaction","orders","addr","derivedAddresses","utxoset","changeAddress","memo","fromAddrsStr","fromAddrs","map","val","parseAddress","changeAddr","stringToAddress","getAVAXAssetID","AVAX_ID_BUF","AVAX_ID_STR","toString","TO_BUF","aad","ZERO","isFeeAdded","i","length","order","asset","tx","assetId","cb58Decode","amt","amount","addAssetAmount","getTxFee","gt","success","getMinimumSpendable","ins","outs","getInputs","getAllOutputs","nftUtxos","filter","getNetworkID","chainId","getBlockchainID","nftSet","addArray","utxoIds","getUTXOIDs","sort","a","b","unsignedTx","buildNFTTransferTx","undefined","rawTx","getTransaction","outsNft","getOuts","insNft","getIns","concat","baseTx","buildCreateNftFamilyTx","symbol","groupNum","minterAddr","utxoSet","fromAddresses","minterAddress","minterSets","minterSet","push","buildCreateNFTAssetTx","buildMintNftTx","mintUtxo","payload","quantity","ownerAddress","Promise","addrBuf","owners","sourceAddresses","owner","groupID","getOutput","getGroupID","buildCreateNFTMintTx","getUTXOID","mintTx","buildExportTransaction","sourceChain","destinationChain","toAddress","sourceChangeAddress","evmBechAddress","destinationChainId","buildExportTx","eth","getTransactionCount","txcount","nonce","avaxAssetIDBuf","avaxAssetIDStr","cb58Encode","fromAddressHex","fromAddressBech","BASETX","CREATEASSETTX","OPERATIONTX","IMPORTTX","EXPORTTX","ADDVALIDATORTX","ADDDELEGATORTX","ADDSUBNETVALIDATORTX","CREATECHAINTX","CREATESUBNETTX","ADVANCETIMETX","REWARDVALIDATORTX","ivSize","saltSize","tagLength","aesLength","keygenIterations","_pwcleaner","password","slt","pw","from","sha256","_keyMaterial","pwkey","window","crypto","subtle","importKey","Uint8Array","_deriveKey","keyMaterial","salt","deriveKey","iterations","hash","message","buff","update","digest","makeSalt","alloc","getRandomValues","pwhash","encrypt","plaintext","pt","pkey","iv","additionalData","ciphertext","decrypt","cryptoHelpers","Crypto","KEYSTORE_VERSION","ITERATIONS_V2","ITERATIONS_V3","readV2","data","pass","version","pass_hash","checkHash","checkHashString","keys","keysDecrypt","key_data","key","key_decrypt","key_string","activeIndex","readV3","readV4","readV5","readV6","type","readKeyFile","extractKeysV2","file","chainID","getBlockchainAlias","pk","keypair","keyBuf","getPrivateKey","keyHex","paddedKeyHex","padStart","mnemonic","extractKeysV5","extractKeysV6","extractKeysFromDecryptedFile","makeKeyfile","wallets","wallet","pk_crypt","file_data","api_url","explorer_api","create","baseURL","withCredentials","headers","getAddressHistory","addrs","limit","endTime","ADDR_SIZE","selection","slice","remaining","addrsRaw","rootUrl","req","address","disableCount","disableGenesis","console","log","post","res","txs","transactions","next","nextRes","getAddressChains","rawAddrs","urlRoot","addressChains","rpcUrl","web3","getAtomicUTXOsForAddresses","chainAlias","getAtomicUTXOs","nextSet","merge","endIndex","getUTXOs","result","utxos","resultP","resultC","INDEX_RANGE","SCAN_SIZE","SCAN_RANGE","changePath","masterKey","isPublic","isFetchUtxo","isInit","hrp","keyChain","keyCache","addressCache","hdCache","hdIndex","oninit","findHdIndex","onNetworkChange","clearCache","incrementIndex","newIndex","keychain","newKey","getKeyForIndex","addKey","network","store","state","Network","selectedNetwork","findAvailableIndexExplorer","findAvailableIndexNode","updateKeychain","platformGetAllUTXOsForAddresses","response","nextEndIndex","len","numFetched","subUtxos","avmGetAllUTXOsForAddresses","getAllUTXOs","avmGetAllUTXOs","chunk","remainingChunk","newSet","platformGetAllUTXOs","updateUtxos","error","getAllDerivedAddresses","currentAddr","getCurrentAddress","currentAddrBuf","currentUtxos","getExtendedAddresses","getUtxos","getKeychain","getAllDerivedKeys","upTo","set","start","getAddressForIndex","startIndex","addrChains","gapSize","n","scanIndex","scanAddr","rawAddr","chains","addrUTXOs","targetIndex","getFirstAvailableIndex","getFirstAvailableAddress","idx","getCurrentKey","index","isPrivate","cacheExternal","pkHex","derivationPath","derive","publicKey","privateKey","pkBuf","pkBuff","addressFromPublicKey","addressToString","findAddressIndex","indexOf","uniqid","accountHdKey","platformUtxoset","stakeAmount","isFetchUtxos","externalHelper","internalHelper","platformHelper","then","updateInitState","getUTXOSet","updateAvmUTXOSet","setExternal","setInternal","joined","getDerivedAddresses","getChangeAddress","updateFetchState","getStake","getAllDerivedExternalAddresses","internal","external","getDerivedAddressesP","getAllAddressesX","getAllAddressesP","getHistoryAddresses","internalIndex","externalIndex","Math","max","getExtendedPlatformAddresses","getChangePath","getChangeIndex","getChangeFromIndex","getPlatformRewardAddress","getCurrentPlatformAddress","getPlatformUTXOSet","getPlatformActiveIndex","getExternalActiveIndex","getBaseAddress","getAllStake","chunkStake","add","uptoIndex","onnetworkchange","addToDict","dict","utxo","addresses","addrDiff","getNFTsSummary","nftLoss","getLossNFT","nftGain","getGainNFT","sent","received","walletAddrs","addrsStripped","inputs","outputs","loss","assets","nfts","input","output","outputType","NFTXFEROUTPUTID","nftsOuts","assetID","intersect","nftOut","doesMatch","addrNotAdded","gain","nftsIns","nftIn","getLoss","isNft","amountBN","receivers","forEach","outAddrs","targets","getProfit","profit","senders","getTransactionSummary","losses","profits","nftSummary","sum","tokens","collectibles","mul","bippath","app","hdkey","config","ethAddress","ethBalance","ethAddressBech","fromApp","getWalletExtendedPublicKey","hd","public_key","chainCode","chain_code","LedgerWallet","getTransactionPaths","isAVM","txType","getTxType","operations","getOperations","e","items","getImportInputs","paths","isAvaxOnly","item","getAssetID","Assets","AVA_ASSET_ID","sigidxs","getInput","getSigIdxs","sources","sigidx","source","j","srcAddr","pathStr","getPathFromAddress","op","getOperation","pathsToUniqueBipPaths","uniquePaths","bip32Paths","path","fromString","getChangeBipPath","chainChangePath","changeIdx","getCredentials","sigMap","creds","cred","getCredentialID","pathIndex","sigRaw","get","sigBuff","sig","fromBuffer","addSignature","signTransactionHash","txbuff","toBuffer","msg","commit","title","messages","info","toUpperCase","accountPath","signHash","sigs","signedTx","signTransactionParsable","parseableTxs","getTransactionMessages","signTransaction","ledgerSignedTx","signatures","getOutputMessages","toPathArray","getAddresses","value","getAmount","outputMessages","getExportOutputs","format","nodeID","startTime","getStartTime","utc","getEndTime","stakeAmt","getStakeAmount","delegationFee","sign","canLedgerParse","isParsableType","getEvmAddress","getEthBalance","setTimeout","externalAddrs","internalAddrs","platformAddrs","extIndex","intIndex","platformIndex","issueBatchTx","issueTx","txId","chainTransfer","fee","amtFee","pId","xId","xChangeAddr","exportTx","pChangeAddr","importToPlatformChain","Error","pToAddr","getHRP","utxoAddrs","ownerAddrs","buildImportTx","importToXChain","xToAddr","sourceChainId","importToCChain","delegate","end","rewardAddress","pAddressStrings","stakeReturnAddr","round","getTime","buildAddDelegatorTx","validate","buildAddValidatorTx","signMessage","msgStr","addressPath","digestBuff","digestHex","signed","createNftFamily","mintNft","sendEth","to","gasPrice","gasLimit","isoLangs","ab","nativeName","aa","af","ak","sq","am","ar","an","hy","as","av","ae","ay","az","bm","ba","eu","be","bn","bh","bi","bs","br","bg","my","ca","ch","ce","ny","cn","zh_hans","zh_hant","cv","kw","co","cr","hr","cs","da","dv","nl","en","eo","et","ee","fo","fj","fi","fr","ff","gl","ka","de","el","gn","gu","ht","ha","he","hz","hi","ho","hu","ia","ie","ga","ig","ik","io","is","it","iu","ja","jv","kl","kn","ks","kk","km","ki","rw","ky","kv","kg","kr","ku","kj","la","lb","lg","li","ln","lo","lt","lu","lv","gv","mk","mg","ms","ml","mt","mi","mr","mh","mn","na","nv","nb","nd","ne","ng","nn","no","ii","nr","oc","oj","cu","om","or","os","pa","pi","fa","pl","ps","qu","rm","rn","ro","ru","sa","sc","sd","se","sm","sg","sr","gd","sn","si","sk","sl","so","st","es","su","sw","ss","sv","ta","te","tg","th","ti","bo","tk","tl","tn","tr","ts","tt","tw","ty","ug","uk","ur","uz","ve","vn","vo","wa","cy","wo","fy","xh","yi","yo","za","chainIdP","keyPair","platformKeyChain","platformKeyPair","ethKey","cPrivKey","ethKeyBech","cKeyChain","ethKeyChain","cKeypair","getAddressString","destinationAddr","getBalance","bal","pAddrs","getAddressStrings","xAddrs","utxoResponse","ownerAddresses","receiver","txAmount","fromAddr","account","accounts","privateKeyToAccount","txConfig","gas","sendSignedTransaction","rawTransaction","receipt","err","transactionHash","bnToBig","denomination","div","pow","keyToKeypair","calculateStakingReward","duration","currentSupply","networkID","defValues","P","maxConsumption","minConsumption","diffConsumption","maxSupply","maxStakingDuration","remainingSupply","sub","amtBig","currentSupplyBig","remainingSupplyBig","portionOfExistingSupplyBig","portionOfStakingDuration","toNumber","mintingRate","rewardBig","times","rewardStr","toFixed","rewardBN","digestMessage","mBuf","msgSize","writeUInt32BE","msgBuf","payloadtypes","getInstance","getPayloadFromUTXO","out","getPayloadBuffer","typeId","getTypeID","getContent","payloadbase","select","amountLocked","amountExtra","addBalance","addBalanceLocked","addExtra","resetBalance","locked","getAmountBN","getTotalAmount","toStringTotal","big","toLocaleString","AVA_TOKEN_INDEX","AVA_ACCOUNT_PATH","ETH_ACCOUNT_PATH","seed","masterHdKey","fromMasterSeed","ethAccountKey","ethPrivateKey","hdKey","isLoading","isInternal","getMnemonic","getKeyChain","allKeys","getExtendedKeyChain","keychainP"],"mappings":"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","file":"js/app~63defed8.1797289d.js","sourcesContent":["let network_id: number = 0\n\nclass AvaNetwork {\n    name: string\n    id: number\n    protocol: string\n    port: number\n    ip: string\n    networkId: number\n    // chainId: string;\n    url: string\n    explorerUrl: string | undefined\n    explorerSiteUrl: string | undefined\n    readonly: boolean\n    // fee: BN\n\n    constructor(\n        name: string,\n        url: string,\n        networkId: number,\n        explorerUrl?: string,\n        explorerSiteUrl?: string,\n        readonly = false\n    ) {\n        this.id = network_id++\n        this.name = name\n        this.explorerUrl = explorerUrl\n        this.explorerSiteUrl = explorerSiteUrl\n        this.protocol = 'http'\n        this.port = 9650\n        this.ip = 'localhost'\n        this.url = url\n        this.updateURL(url)\n        this.networkId = networkId\n        // this.chainId = chainId;\n        this.readonly = readonly\n        // this.fee = new BN(0);\n    }\n\n    updateURL(url: string) {\n        let split: string[] = url.split('://')\n\n        this.protocol = split[0]\n\n        // port is set\n        if (split[1].includes(':')) {\n            let urlSplit: string[] = split[1].split(':')\n            let ip: string = urlSplit[0]\n            let port: string = urlSplit[1]\n\n            this.ip = ip\n            this.port = parseInt(port)\n        } else {\n            this.ip = split[1]\n            if (this.protocol === 'http') {\n                this.port = 80\n            } else {\n                this.port = 443\n            }\n        }\n    }\n    getFullURL() {\n        return `${this.protocol}://${this.ip}:${this.port}`\n    }\n}\n\nexport { AvaNetwork }\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { BN, Buffer } from 'avalanche'\nimport {\n    AssetAmountDestination,\n    BaseTx,\n    MinterSet,\n    NFTMintOutput,\n    TransferableInput,\n    TransferableOutput,\n    UnsignedTx as AVMUnsignedTx,\n    UTXO as AVMUTXO,\n    UTXOSet,\n    UTXOSet as AVMUTXOSet,\n    AVMConstants,\n} from 'avalanche/dist/apis/avm'\n\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { OutputOwners } from 'avalanche/dist/common'\nimport {\n    UTXOSet as PlatformUTXOSet,\n    UnsignedTx as PlatformUnsignedTx,\n    PlatformVMConstants,\n} from 'avalanche/dist/apis/platformvm'\n\nimport { UnsignedTx as EVMUnsignedTx } from 'avalanche/dist/apis/evm'\nimport { ChainIdType } from '@/constants'\n\nimport { web3 } from '@/evm'\n\nexport async function buildUnsignedTransaction(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    derivedAddresses: string[],\n    utxoset: AVMUTXOSet,\n    changeAddress?: string,\n    memo?: Buffer\n) {\n    // TODO: Get new change index.\n    if (!changeAddress) {\n        throw 'Unable to issue transaction. Ran out of change index.'\n    }\n\n    let fromAddrsStr: string[] = derivedAddresses\n    let fromAddrs: Buffer[] = fromAddrsStr.map((val) => bintools.parseAddress(val, 'X'))\n    let changeAddr: Buffer = bintools.stringToAddress(changeAddress)\n\n    // TODO: use internal asset ID\n    // This does not update on network change, causing issues\n    const AVAX_ID_BUF = await avm.getAVAXAssetID()\n    const AVAX_ID_STR = AVAX_ID_BUF.toString('hex')\n    const TO_BUF = bintools.stringToAddress(addr)\n\n    const aad: AssetAmountDestination = new AssetAmountDestination([TO_BUF], fromAddrs, [\n        changeAddr,\n    ])\n    const ZERO = new BN(0)\n    let isFeeAdded = false\n\n    // Aggregate Fungible ins & outs\n    for (let i: number = 0; i < orders.length; i++) {\n        let order: ITransaction | AVMUTXO = orders[i]\n\n        if ((order as ITransaction).asset) {\n            // if fungible\n            let tx: ITransaction = order as ITransaction\n\n            let assetId = bintools.cb58Decode(tx.asset.id)\n            let amt: BN = tx.amount\n\n            if (assetId.toString('hex') === AVAX_ID_STR) {\n                aad.addAssetAmount(assetId, amt, avm.getTxFee())\n                isFeeAdded = true\n            } else {\n                aad.addAssetAmount(assetId, amt, ZERO)\n            }\n        }\n    }\n\n    // If fee isn't added, add it\n    if (!isFeeAdded) {\n        if (avm.getTxFee().gt(ZERO)) {\n            aad.addAssetAmount(AVAX_ID_BUF, ZERO, avm.getTxFee())\n        }\n    }\n\n    const success: Error = utxoset.getMinimumSpendable(aad)\n\n    let ins: TransferableInput[] = []\n    let outs: TransferableOutput[] = []\n    if (typeof success === 'undefined') {\n        ins = aad.getInputs()\n        outs = aad.getAllOutputs()\n    } else {\n        throw success\n    }\n\n    //@ts-ignore\n    let nftUtxos: UTXO[] = orders.filter((val) => {\n        if ((val as ITransaction).asset) return false\n        return true\n    })\n\n    // If transferring an NFT, build the transaction on top of an NFT tx\n    let unsignedTx: AVMUnsignedTx\n    let networkId: number = ava.getNetworkID()\n    let chainId: Buffer = bintools.cb58Decode(avm.getBlockchainID())\n\n    if (nftUtxos.length > 0) {\n        let nftSet = new AVMUTXOSet()\n        nftSet.addArray(nftUtxos)\n\n        let utxoIds: string[] = nftSet.getUTXOIDs()\n\n        // Sort nft utxos\n        utxoIds.sort((a, b) => {\n            if (a < b) {\n                return -1\n            } else if (a > b) {\n                return 1\n            }\n            return 0\n        })\n\n        unsignedTx = nftSet.buildNFTTransferTx(\n            networkId,\n            chainId,\n            [TO_BUF],\n            fromAddrs,\n            fromAddrs, // change address should be something else?\n            utxoIds,\n            undefined,\n            undefined,\n            memo\n        )\n\n        let rawTx = unsignedTx.getTransaction()\n        let outsNft = rawTx.getOuts()\n        let insNft = rawTx.getIns()\n\n        // TODO: This is a hackish way of doing this, need methods in avalanche.js\n        //@ts-ignore\n        rawTx.outs = outsNft.concat(outs)\n        //@ts-ignore\n        rawTx.ins = insNft.concat(ins)\n    } else {\n        let baseTx: BaseTx = new BaseTx(networkId, chainId, outs, ins, memo)\n        unsignedTx = new AVMUnsignedTx(baseTx)\n    }\n    return unsignedTx\n}\n\nexport async function buildCreateNftFamilyTx(\n    name: string,\n    symbol: string,\n    groupNum: number,\n    fromAddrs: string[],\n    minterAddr: string,\n    changeAddr: string,\n    utxoSet: UTXOSet\n) {\n    let fromAddresses = fromAddrs\n    let changeAddress = changeAddr\n    let minterAddress = minterAddr\n\n    const minterSets: MinterSet[] = []\n\n    // Create the groups\n    for (var i = 0; i < groupNum; i++) {\n        const minterSet: MinterSet = new MinterSet(1, [minterAddress])\n        minterSets.push(minterSet)\n    }\n\n    let unsignedTx: AVMUnsignedTx = await avm.buildCreateNFTAssetTx(\n        utxoSet,\n        fromAddresses,\n        [changeAddress],\n        minterSets,\n        name,\n        symbol\n    )\n    return unsignedTx\n}\n\nexport async function buildMintNftTx(\n    mintUtxo: AVMUTXO,\n    payload: PayloadBase,\n    quantity: number,\n    ownerAddress: string,\n    changeAddress: string,\n    fromAddresses: string[],\n    utxoSet: UTXOSet\n): Promise<AVMUnsignedTx> {\n    let addrBuf = bintools.parseAddress(ownerAddress, 'X')\n    let owners = []\n\n    let sourceAddresses = fromAddresses\n\n    for (var i = 0; i < quantity; i++) {\n        let owner = new OutputOwners([addrBuf])\n        owners.push(owner)\n    }\n\n    let groupID = (mintUtxo.getOutput() as NFTMintOutput).getGroupID()\n\n    let mintTx = await avm.buildCreateNFTMintTx(\n        utxoSet,\n        owners,\n        sourceAddresses,\n        [changeAddress],\n        mintUtxo.getUTXOID(),\n        groupID,\n        payload\n    )\n    return mintTx\n}\nexport async function buildExportTransaction(\n    sourceChain: ChainIdType,\n    destinationChain: ChainIdType,\n    utxoSet: AVMUTXOSet | PlatformUTXOSet,\n    fromAddresses: string[],\n    toAddress: string,\n    amount: BN, // export amount + fee\n    sourceChangeAddress: string,\n    evmBechAddress?: string // Used ONLY for c chain exports\n): Promise<AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx> {\n    let destinationChainId\n    switch (destinationChain) {\n        case 'X':\n            destinationChainId = avm.getBlockchainID()\n            break\n        case 'P':\n            destinationChainId = pChain.getBlockchainID()\n            break\n        case 'C':\n            destinationChainId = cChain.getBlockchainID()\n            break\n    }\n    if (sourceChain === 'X') {\n        return await avm.buildExportTx(\n            utxoSet as AVMUTXOSet,\n            amount,\n            destinationChainId,\n            [toAddress],\n            fromAddresses,\n            [sourceChangeAddress]\n        )\n    } else if (sourceChain === 'P') {\n        return await pChain.buildExportTx(\n            utxoSet as PlatformUTXOSet,\n            amount,\n            destinationChainId,\n            [toAddress],\n            fromAddresses,\n            [sourceChangeAddress]\n        )\n    } else if (sourceChain === 'C') {\n        const txcount = await web3.eth.getTransactionCount(fromAddresses[0])\n        const nonce: number = txcount\n        const avaxAssetIDBuf: Buffer = await avm.getAVAXAssetID()\n        const avaxAssetIDStr: string = bintools.cb58Encode(avaxAssetIDBuf)\n\n        let fromAddressHex = fromAddresses[0]\n        let fromAddressBech = evmBechAddress!\n\n        return await cChain.buildExportTx(\n            amount,\n            avaxAssetIDStr,\n            destinationChainId,\n            fromAddressHex,\n            fromAddressBech,\n            [toAddress],\n            nonce\n        )\n    }\n    throw 'Invalid source chain.'\n}\n\nexport enum AvmTxNameEnum {\n    'Transaction' = AVMConstants.BASETX,\n    'Mint' = AVMConstants.CREATEASSETTX,\n    'Operation' = AVMConstants.OPERATIONTX,\n    'Import' = AVMConstants.IMPORTTX,\n    'Export' = AVMConstants.EXPORTTX,\n}\n\nexport enum PlatfromTxNameEnum {\n    'Transaction' = PlatformVMConstants.BASETX,\n    'Add Validator' = PlatformVMConstants.ADDVALIDATORTX,\n    'Add Delegator' = PlatformVMConstants.ADDDELEGATORTX,\n    'Import' = PlatformVMConstants.IMPORTTX,\n    'Export' = PlatformVMConstants.EXPORTTX,\n    'Add Subnet Validator' = PlatformVMConstants.ADDSUBNETVALIDATORTX,\n    'Create Chain' = PlatformVMConstants.CREATECHAINTX,\n    'Create Subnet' = PlatformVMConstants.CREATESUBNETTX,\n    'Advance Time' = PlatformVMConstants.ADVANCETIMETX,\n    'Reward Validator' = PlatformVMConstants.REWARDVALIDATORTX,\n}\n\n// TODO: create asset transactions\nexport enum ParseableAvmTxEnum {\n    'Transaction' = AVMConstants.BASETX,\n    'Import' = AVMConstants.IMPORTTX,\n    'Export' = AVMConstants.EXPORTTX,\n}\n\nexport enum ParseablePlatformEnum {\n    'Transaction' = PlatformVMConstants.BASETX,\n    'Add Validator' = PlatformVMConstants.ADDVALIDATORTX,\n    'Add Delegator' = PlatformVMConstants.ADDDELEGATORTX,\n    'Import' = PlatformVMConstants.IMPORTTX,\n    'Export' = PlatformVMConstants.EXPORTTX,\n}\n","import { Buffer } from 'buffer/'\nimport createHash from 'create-hash'\n\n/**\n * @ignore\n */\n\n/**\n * Helper utility for encryption and password hashing, browser-safe.\n * Encryption is using AES-GCM with a random public nonce.\n */\nexport default class CryptoHelpers {\n    protected ivSize: number = 12\n\n    protected saltSize: number = 16\n\n    protected tagLength: number = 128\n\n    protected aesLength: number = 256\n\n    public keygenIterations: number = 200000 //3.0, 2.0 uses 100000\n\n    /**\n     * Internal-intended function for cleaning passwords.\n     *\n     * @param password\n     * @param salt\n     */\n    _pwcleaner(password: string, slt: Buffer): Buffer {\n        const pw: Buffer = Buffer.from(password, 'utf8')\n        return this.sha256(Buffer.concat([pw, slt]))\n    }\n    /**\n     * Internal-intended function for producing an intermediate key.\n     *\n     * @param pwkey\n     */\n\n    async _keyMaterial(pwkey: Buffer): Promise<CryptoKey> {\n        return window.crypto.subtle.importKey(\n            'raw',\n            new Uint8Array(pwkey),\n            { name: 'PBKDF2' },\n            false,\n            ['deriveKey']\n        )\n    }\n\n    /**\n     * Internal-intended function for turning an intermediate key into a salted key.\n     *\n     * @param keyMaterial\n     * @param salt\n     */\n    async _deriveKey(keyMaterial: CryptoKey, salt: Buffer): Promise<CryptoKey> {\n        return window.crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt,\n                iterations: this.keygenIterations,\n                hash: 'SHA-256',\n            },\n            keyMaterial,\n            { name: 'AES-GCM', length: this.aesLength },\n            false,\n            ['encrypt', 'decrypt']\n        )\n    }\n\n    /**\n     * A SHA256 helper function.\n     *\n     * @param message The message to hash\n     *\n     * @returns A {@link https://github.com/feross/buffer|Buffer} containing the SHA256 hash of the message\n     */\n    sha256(message: string | Buffer): Buffer {\n        let buff: Buffer\n        if (typeof message === 'string') {\n            buff = Buffer.from(message, 'utf8')\n        } else {\n            buff = Buffer.from(message)\n        }\n        return Buffer.from(createHash('sha256').update(buff).digest()) // ensures correct Buffer class is used\n    }\n\n    /**\n     * Generates a randomized {@link https://github.com/feross/buffer|Buffer} to be used as a salt\n     */\n    makeSalt(): Buffer {\n        const salt = Buffer.alloc(this.saltSize)\n        window.crypto.getRandomValues(salt)\n        return salt\n    }\n\n    /**\n     * Produces a password-safe hash.\n     *\n     * @param password A string for the password\n     * @param salt An optional {@link https://github.com/feross/buffer|Buffer} containing a salt used in the password hash\n     *\n     * @returns An object containing the \"salt\" and the \"hash\" produced by this function, both as {@link https://github.com/feross/buffer|Buffer}.\n     */\n    async pwhash(password: string, salt: Buffer): Promise<{ salt: Buffer; hash: Buffer }> {\n        let slt: Buffer\n        if (salt instanceof Buffer) {\n            slt = salt\n            // @ts-ignore\n        } else if (salt instanceof Uint8Array && process.env.NODE_ENV === 'test') {\n            slt = salt\n        } else {\n            slt = this.makeSalt()\n        }\n\n        const hash: Buffer = this._pwcleaner(password, this._pwcleaner(password, slt))\n        return { salt: slt, hash }\n    }\n\n    /**\n     * Encrypts plaintext with the provided password using AES-GCM.\n     *\n     * @param password A string for the password\n     * @param plaintext The plaintext to encrypt\n     * @param salt An optional {@link https://github.com/feross/buffer|Buffer} for the salt to use in the encryption process\n     *\n     * @returns An object containing the \"salt\", \"iv\", and \"ciphertext\", all as {@link https://github.com/feross/buffer|Buffer}.\n     */\n    async encrypt(\n        password: string,\n        plaintext: Buffer | string,\n        salt: Buffer | undefined = undefined\n    ): Promise<{ salt: Buffer; iv: Buffer; ciphertext: Buffer }> {\n        let slt: Buffer\n        if (typeof salt !== 'undefined' && salt instanceof Buffer) {\n            slt = salt\n        } else {\n            slt = this.makeSalt()\n        }\n\n        let pt: Buffer\n        if (typeof plaintext !== 'undefined' && plaintext instanceof Buffer) {\n            pt = plaintext\n        } else {\n            pt = Buffer.from(plaintext, 'utf8')\n        }\n        const pwkey: Buffer = this._pwcleaner(password, slt)\n        const keyMaterial: CryptoKey = await this._keyMaterial(pwkey)\n        const pkey: CryptoKey = await this._deriveKey(keyMaterial, slt)\n        const iv: Buffer = Buffer.from(window.crypto.getRandomValues(new Uint8Array(this.ivSize)))\n\n        const ciphertext: Buffer = Buffer.from(\n            await window.crypto.subtle.encrypt(\n                {\n                    name: 'AES-GCM',\n                    iv,\n                    additionalData: slt,\n                    tagLength: this.tagLength,\n                },\n                pkey,\n                pt\n            )\n        )\n\n        return {\n            salt: slt,\n            iv,\n            ciphertext,\n        }\n    }\n\n    /**\n     * Decrypts ciphertext with the provided password, iv, and salt.\n     *\n     * @param password A string for the password\n     * @param ciphertext A {@link https://github.com/feross/buffer|Buffer} for the ciphertext\n     * @param salt A {@link https://github.com/feross/buffer|Buffer} for the salt\n     * @param iv A {@link https://github.com/feross/buffer|Buffer} for the iv\n     */\n    async decrypt(password: string, ciphertext: Buffer, salt: Buffer, iv: Buffer): Promise<Buffer> {\n        const pwkey: Buffer = this._pwcleaner(password, salt)\n        const keyMaterial: CryptoKey = await this._keyMaterial(pwkey)\n        const pkey: CryptoKey = await this._deriveKey(keyMaterial, salt)\n\n        const pt: Buffer = Buffer.from(\n            await window.crypto.subtle.decrypt(\n                {\n                    name: 'AES-GCM',\n                    iv, // The initialization vector you used to encrypt\n                    additionalData: salt, // The addtionalData you used to encrypt (if any)\n                    tagLength: 128, // The tagLength you used to encrypt (if any)\n                },\n                pkey, // from generateKey or importKey above\n                ciphertext // ArrayBuffer of the data\n            )\n        )\n        return pt\n    }\n\n    constructor() {}\n}\n","// Functions to manage import/export of keystore files\nimport {\n    AllKeyFileDecryptedTypes,\n    AllKeyFileTypes,\n    KeyFileDecryptedV2,\n    KeyFileDecryptedV3,\n    KeyFileDecryptedV4,\n    KeyFileDecryptedV5,\n    KeyFileDecryptedV6,\n    KeyFileKeyDecryptedV2,\n    KeyFileKeyDecryptedV3,\n    KeyFileKeyDecryptedV4,\n    KeyFileKeyDecryptedV5,\n    KeyFileKeyDecryptedV6,\n    KeyFileKeyV2,\n    KeyFileKeyV3,\n    KeyFileKeyV4,\n    KeyFileKeyV5,\n    KeyFileKeyV6,\n    KeyFileV2,\n    KeyFileV3,\n    KeyFileV4,\n    KeyFileV5,\n    KeyFileV6,\n    KeystoreFileKeyType,\n} from './IKeystore'\nimport { avm, bintools } from '@/AVA'\nimport { Buffer } from 'buffer/'\nimport AvaHdWallet from '@/js/wallets/AvaHdWallet'\nimport Crypto from '@/js/Crypto'\nimport { SingletonWallet } from '@/js/wallets/SingletonWallet'\nimport { AccessWalletMultipleInput } from '@/store/types'\nimport { keyToKeypair } from '@/helpers/helper'\nimport * as bip39 from 'bip39'\n\nconst cryptoHelpers = new Crypto()\n\nconst KEYSTORE_VERSION: string = '6.0'\n\nconst ITERATIONS_V2 = 100000\nconst ITERATIONS_V3 = 200000 // and any version above\n\nconst SUPPORTED_VERSION = ['2.0', '3.0', '4.0', '5.0', '6.0']\n\ninterface IHash {\n    salt: Buffer\n    hash: Buffer\n}\n\ninterface PKCrypt {\n    salt: Buffer\n    iv: Buffer\n    ciphertext: Buffer\n}\n\nasync function readV2(data: KeyFileV2, pass: string) {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V2\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: Buffer = await cryptoHelpers._pwcleaner(pass, salt)\n    checkHashString = bintools.cb58Encode(checkHash)\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV2[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV2[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV2 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(key_decrypt)\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\nasync function readV3(data: KeyFileV3, pass: string) {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(checkHash.hash)\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV3[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV3[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV3 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(key_decrypt)\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\nasync function readV4(data: KeyFileV4, pass: string): Promise<KeyFileDecryptedV5> {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(checkHash.hash)\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV4[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV4[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV4 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(key_decrypt)\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readV5(data: KeyFileV5, pass: string): Promise<KeyFileDecryptedV5> {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(checkHash.hash)\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV5[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV5[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV5 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = key_decrypt.toString()\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readV6(data: KeyFileV6, pass: string): Promise<KeyFileDecryptedV6> {\n    const version: string = data.version\n    const activeIndex = data.activeIndex\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n\n    let keys: KeyFileKeyV6[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV6[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV6 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let type: KeystoreFileKeyType = key_data.type\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer\n        try {\n            key_decrypt = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        } catch (e) {\n            throw 'INVALID_PASS'\n        }\n\n        const key_string = key_decrypt.toString()\n\n        keysDecrypt.push({\n            key: key_string,\n            type: type,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: activeIndex || 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readKeyFile(data: AllKeyFileTypes, pass: string): Promise<AllKeyFileDecryptedTypes> {\n    switch (data.version) {\n        case '6.0':\n            return await readV6(data as KeyFileV6, pass)\n        case '5.0':\n            return await readV5(data as KeyFileV5, pass)\n        case '4.0':\n            return await readV4(data as KeyFileV4, pass)\n        case '3.0':\n            return await readV3(data as KeyFileV3, pass)\n        case '2.0':\n            return await readV2(data as KeyFileV2, pass)\n        default:\n            throw 'INVALID_VERSION'\n    }\n}\n\nfunction extractKeysV2(\n    file: KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4\n): AccessWalletMultipleInput[] {\n    let chainID = avm.getBlockchainAlias()\n    let keys = (file as KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4).keys\n\n    return keys.map((key) => {\n        // Private keys from the keystore file do not have the PrivateKey- prefix\n        let pk = 'PrivateKey-' + key.key\n        let keypair = keyToKeypair(pk, chainID)\n\n        let keyBuf = keypair.getPrivateKey()\n        let keyHex: string = keyBuf.toString('hex')\n        let paddedKeyHex = keyHex.padStart(64, '0')\n        let mnemonic: string = bip39.entropyToMnemonic(paddedKeyHex)\n\n        return {\n            key: mnemonic,\n            type: 'mnemonic',\n        }\n    })\n}\n\nfunction extractKeysV5(file: KeyFileDecryptedV5): AccessWalletMultipleInput[] {\n    return file.keys.map((key) => ({\n        key: key.key,\n        type: 'mnemonic',\n    }))\n}\n\nfunction extractKeysV6(file: KeyFileDecryptedV6): AccessWalletMultipleInput[] {\n    return file.keys.map((key) => ({\n        type: key.type,\n        key: key.key,\n    }))\n}\n\nfunction extractKeysFromDecryptedFile(file: AllKeyFileDecryptedTypes): AccessWalletMultipleInput[] {\n    switch (file.version) {\n        case '6.0':\n            return extractKeysV6(file as KeyFileDecryptedV6)\n        case '5.0':\n            return extractKeysV5(file as KeyFileDecryptedV5)\n        case '4.0':\n            return extractKeysV2(file as KeyFileDecryptedV4)\n        case '3.0':\n            return extractKeysV2(file as KeyFileDecryptedV3)\n        case '2.0':\n            return extractKeysV2(file as KeyFileDecryptedV2)\n        default:\n            throw 'INVALID_VERSION'\n    }\n}\n\n// Given an array of wallets and a password, return an encrypted JSON object that is the keystore file\nasync function makeKeyfile(\n    wallets: (AvaHdWallet | SingletonWallet)[],\n    pass: string,\n    activeIndex: number\n): Promise<KeyFileV6> {\n    // 3.0 and above uses 200,000\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = await cryptoHelpers.makeSalt()\n\n    let keys: KeyFileKeyV6[] = []\n\n    for (let i: number = 0; i < wallets.length; i++) {\n        let wallet = wallets[i]\n        let key\n        let type: KeystoreFileKeyType\n        if (wallet.type === 'singleton') {\n            key = (wallet as SingletonWallet).key\n            type = 'singleton'\n        } else {\n            key = (wallet as AvaHdWallet).mnemonic\n            type = 'mnemonic'\n        }\n        let pk_crypt: PKCrypt = await cryptoHelpers.encrypt(pass, key, salt)\n\n        let key_data: KeyFileKeyV6 = {\n            key: bintools.cb58Encode(pk_crypt.ciphertext),\n            iv: bintools.cb58Encode(pk_crypt.iv),\n            type: type,\n        }\n        keys.push(key_data)\n    }\n\n    let file_data: KeyFileV6 = {\n        version: KEYSTORE_VERSION,\n        salt: bintools.cb58Encode(salt),\n        activeIndex,\n        keys: keys,\n    }\n    return file_data\n}\n\nexport { readKeyFile, makeKeyfile, KEYSTORE_VERSION, extractKeysFromDecryptedFile }\n","import axios, { AxiosInstance } from 'axios'\nimport { ITransactionData } from './store/modules/history/types'\n\n// Doesn't really matter what we set, it will change\nconst api_url: string = 'localhost'\nconst explorer_api: AxiosInstance = axios.create({\n    baseURL: api_url,\n    withCredentials: false,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n})\n\nasync function getAddressHistory(\n    addrs: string[],\n    limit = 20,\n    chainID: string,\n    endTime?: string\n): Promise<ITransactionData[]> {\n    const ADDR_SIZE = 1024\n    let selection = addrs.slice(0, ADDR_SIZE)\n    let remaining = addrs.slice(ADDR_SIZE)\n\n    let addrsRaw = selection.map((addr) => {\n        return addr.split('-')[1]\n    })\n\n    let rootUrl = 'v2/transactions'\n\n    let req = {\n        address: addrsRaw,\n        sort: ['timestamp-desc'],\n        disableCount: ['1'],\n        chainID: [chainID],\n        disableGenesis: ['false'],\n    }\n\n    if (limit > 0) {\n        //@ts-ignore\n        req.limit = [limit.toString()]\n    }\n\n    if (endTime) {\n        console.log('Setting endtime')\n        //@ts-ignore\n        req.endTime = [endTime]\n    }\n\n    let res = await explorer_api.post(rootUrl, req)\n    let txs = res.data.transactions\n    let next: string | undefined = res.data.next\n\n    if (txs === null) txs = []\n\n    // If we need to fetch more for this address\n    if (next && !limit) {\n        let endTime = next.split('&')[0].split('=')[1]\n        let nextRes = await getAddressHistory(selection, limit, chainID, endTime)\n        txs.push(...nextRes)\n    }\n\n    // If there are addresses left, fetch them too\n    if (remaining.length > 0) {\n        let nextRes = await getAddressHistory(remaining, limit, chainID)\n        txs.push(...nextRes)\n    }\n\n    return txs\n}\n\nasync function isAddressUsedX(addr: string) {\n    let addrRaw = addr.split('-')[1]\n    let url = `/x/transactions?address=${addrRaw}&limit=1&disableCount=1`\n    try {\n        let res = await explorer_api.get(url)\n        // console.log(res);\n        if (res.data.transactions.length > 0) return true\n        else return false\n    } catch (e) {\n        throw e\n    }\n}\n\nasync function getAddressDetailX(addr: string) {\n    let addrRaw = addr.split('-')[1]\n    let url = `/x/addresses/${addrRaw}`\n\n    try {\n        let res = await explorer_api.get(url)\n        return res.data\n    } catch (e) {\n        throw e\n    }\n}\n\nasync function getAddressChains(addrs: string[]) {\n    // Strip the prefix\n    let rawAddrs = addrs.map((addr) => {\n        return addr.split('-')[1]\n    })\n\n    let urlRoot = `/v2/addressChains`\n\n    let res = await explorer_api.post(urlRoot, {\n        address: rawAddrs,\n        disableCount: ['1'],\n    })\n\n    return res.data.addressChains\n}\n\nexport { explorer_api, getAddressHistory, getAddressDetailX, isAddressUsedX, getAddressChains }\n","import Web3 from 'web3'\nlet rpcUrl = `https://api.avax.network/ext/bc/C/rpc`\n\nlet web3 = new Web3(rpcUrl)\n\nexport { web3 }\n","import { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm/utxos'\nimport { avm, cChain, pChain } from '@/AVA'\nimport { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\n\n// Handles more than 1024 addresses\nasync function getAtomicUTXOsForAddresses(addrs: string[], chainAlias: string): Promise<any> {\n    let selection = addrs.slice(0, 1024)\n    let remaining = addrs.slice(1024)\n\n    let utxoSet = await getAtomicUTXOs(selection, chainAlias)\n\n    if (remaining.length > 0) {\n        // @ts-ignore\n        let nextSet = await getAtomicUTXOsForAddresses(remaining, chainAlias)\n        utxoSet = utxoSet.merge(nextSet)\n    }\n\n    return utxoSet\n}\n\n// todo: Use end index to get ALL utxos\nasync function getAtomicUTXOs(addrs: string[], chainAlias: string, endIndex: any = undefined) {\n    if (addrs.length > 1024) {\n        throw 'Number of addresses can not be greater than 1024.'\n    }\n\n    if (chainAlias === 'P') {\n        let result: PlatformUTXOSet = (await pChain.getUTXOs(addrs, avm.getBlockchainID())).utxos\n        return result\n    } else {\n        let resultP: AVMUTXOSet = (await avm.getUTXOs(addrs, pChain.getBlockchainID())).utxos\n        let resultC: AVMUTXOSet = (await avm.getUTXOs(addrs, cChain.getBlockchainID())).utxos\n        let result = resultP.merge(resultC)\n        return result\n    }\n}\n\nexport { getAtomicUTXOsForAddresses }\n","import {\n    KeyChain as AVMKeyChain,\n    KeyPair as AVMKeyPair,\n    UTXOSet as AVMUTXOSet,\n} from 'avalanche/dist/apis/avm'\nimport { UTXOSet as EVMUTXOSet } from 'avalanche/dist/apis/evm'\n\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm'\nimport { getPreferredHRP } from 'avalanche/dist/utils'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport HDKey from 'hdkey'\nimport { Buffer } from 'buffer/'\nimport {\n    KeyChain as PlatformVMKeyChain,\n    KeyPair as PlatformVMKeyPair,\n} from 'avalanche/dist/apis/platformvm'\nimport store from '@/store'\n\nimport { getAddressChains } from '@/explorer_api'\nimport { NetworkItem } from '@/store/modules/network/types'\nimport { AvaNetwork } from '@/js/AvaNetwork'\nimport { ChainAlias } from './wallets/IAvaHdWallet'\nimport { getAtomicUTXOsForAddresses } from '@/helpers/wallet_helper'\n\nconst INDEX_RANGE: number = 20 // a gap of at least 20 indexes is needed to claim an index unused\n\nconst SCAN_SIZE: number = 100 // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE // How many items are actually scanned\nclass HdHelper {\n    chainId: ChainAlias\n    keyChain: AVMKeyChain | PlatformVMKeyChain\n    keyCache: {\n        [index: number]: AVMKeyPair | PlatformVMKeyPair\n    }\n    addressCache: {\n        [index: number]: string\n    }\n    hdCache: {\n        [index: number]: HDKey\n    }\n    changePath: string\n    masterKey: HDKey\n    hdIndex: number\n    utxoSet: AVMUTXOSet | PlatformUTXOSet\n    isPublic: boolean\n    isFetchUtxo: boolean // true if updating balance\n    isInit: boolean // true if HD index is found\n\n    constructor(\n        changePath: string,\n        masterKey: HDKey,\n        chainId: ChainAlias = 'X',\n        isPublic: boolean = false\n    ) {\n        this.changePath = changePath\n        this.isFetchUtxo = false\n        this.isInit = false\n\n        this.chainId = chainId\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        if (chainId === 'X') {\n            this.keyChain = new AVMKeyChain(hrp, chainId)\n            this.utxoSet = new AVMUTXOSet()\n        } else {\n            this.keyChain = new PlatformVMKeyChain(hrp, chainId)\n            this.utxoSet = new PlatformUTXOSet()\n        }\n\n        this.keyCache = {}\n        this.addressCache = {}\n        this.hdCache = {}\n        this.masterKey = masterKey\n        this.hdIndex = 0\n        this.isPublic = isPublic\n        // this.oninit()\n    }\n\n    async oninit() {\n        await this.findHdIndex()\n        // this.hdIndex = await this.findAvailableIndexNode();\n        // this.hdIndex = await this.findAvailableIndexExplorer();\n\n        // if(!this.isPublic){\n        //     this.updateKeychain();\n        // }\n        // this.updateUtxos()\n    }\n\n    // When the wallet connects to a different network\n    // Clear internal data and scan again\n    async onNetworkChange() {\n        this.clearCache()\n        this.isInit = false\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        if (this.chainId === 'X') {\n            this.keyChain = new AVMKeyChain(hrp, this.chainId)\n            this.utxoSet = new AVMUTXOSet()\n        } else {\n            this.keyChain = new PlatformVMKeyChain(hrp, this.chainId)\n            this.utxoSet = new PlatformUTXOSet()\n        }\n        this.hdIndex = 0\n        await this.oninit()\n    }\n\n    // Increments the hd index by one and adds the key\n    // returns the new keypair\n    incrementIndex(): number {\n        let newIndex: number = this.hdIndex + 1\n\n        if (!this.isPublic) {\n            if (this.chainId === 'X') {\n                let keychain = this.keyChain as AVMKeyChain\n                let newKey = this.getKeyForIndex(newIndex) as AVMKeyPair\n                keychain.addKey(newKey)\n            } else {\n                let keychain = this.keyChain as PlatformVMKeyChain\n                let newKey = this.getKeyForIndex(newIndex) as PlatformVMKeyPair\n                keychain.addKey(newKey)\n            }\n        }\n\n        this.hdIndex = newIndex\n        return newIndex\n    }\n\n    async findHdIndex() {\n        // Check if explorer is available\n\n        // @ts-ignore\n        let network: AvaNetwork = store.state.Network.selectedNetwork\n        let explorerUrl = network.explorerUrl\n\n        if (explorerUrl) {\n            this.hdIndex = await this.findAvailableIndexExplorer()\n        } else {\n            this.hdIndex = await this.findAvailableIndexNode()\n        }\n\n        if (!this.isPublic) {\n            this.updateKeychain()\n        }\n        this.isInit = true\n    }\n\n    async platformGetAllUTXOsForAddresses(\n        addrs: string[],\n        endIndex: any = undefined\n    ): Promise<PlatformUTXOSet> {\n        let response\n        if (!endIndex) {\n            response = await pChain.getUTXOs(addrs)\n        } else {\n            response = await pChain.getUTXOs(addrs, undefined, 0, endIndex)\n        }\n\n        let utxoSet = response.utxos\n        let nextEndIndex = response.endIndex\n        let len = response.numFetched\n\n        if (len >= 1024) {\n            let subUtxos = await this.platformGetAllUTXOsForAddresses(addrs, nextEndIndex)\n            return utxoSet.merge(subUtxos)\n        }\n\n        return utxoSet\n    }\n\n    async avmGetAllUTXOsForAddresses(\n        addrs: string[],\n        endIndex: any = undefined\n    ): Promise<AVMUTXOSet> {\n        let response\n        if (!endIndex) {\n            response = await avm.getUTXOs(addrs)\n        } else {\n            response = await avm.getUTXOs(addrs, undefined, 0, endIndex)\n        }\n\n        let utxoSet = response.utxos\n        let utxos = utxoSet.getAllUTXOs()\n        let nextEndIndex = response.endIndex\n        let len = response.numFetched\n\n        if (len >= 1024) {\n            let subUtxos = await this.avmGetAllUTXOsForAddresses(addrs, nextEndIndex)\n            return utxoSet.merge(subUtxos)\n        }\n        return utxoSet\n    }\n\n    // helper method to get utxos for more than 1024 addresses\n    async avmGetAllUTXOs(addrs: string[]): Promise<AVMUTXOSet> {\n        if (addrs.length <= 1024) {\n            let utxos = await this.avmGetAllUTXOsForAddresses(addrs)\n            return utxos\n        } else {\n            //Break the list in to 1024 chunks\n            let chunk = addrs.slice(0, 1024)\n            let remainingChunk = addrs.slice(1024)\n\n            let newSet = await this.avmGetAllUTXOsForAddresses(chunk)\n            return newSet.merge(await this.avmGetAllUTXOs(remainingChunk))\n        }\n    }\n\n    // helper method to get utxos for more than 1024 addresses\n    async platformGetAllUTXOs(addrs: string[]): Promise<PlatformUTXOSet> {\n        if (addrs.length <= 1024) {\n            let newSet = await this.platformGetAllUTXOsForAddresses(addrs)\n            return newSet\n        } else {\n            //Break the list in to 1024 chunks\n            let chunk = addrs.slice(0, 1024)\n            let remainingChunk = addrs.slice(1024)\n\n            let newSet = await this.platformGetAllUTXOsForAddresses(chunk)\n\n            return newSet.merge(await this.platformGetAllUTXOs(remainingChunk))\n        }\n    }\n\n    // Fetches the utxos for the current keychain\n    // and increments the index if last index has a utxo\n    async updateUtxos(): Promise<AVMUTXOSet | PlatformUTXOSet> {\n        this.isFetchUtxo = true\n\n        if (!this.isInit) {\n            console.error('HD Index not found yet.')\n        }\n\n        let addrs: string[] = this.getAllDerivedAddresses()\n        let result: AVMUTXOSet | PlatformUTXOSet\n\n        if (this.chainId === 'X') {\n            result = await this.avmGetAllUTXOs(addrs)\n        } else {\n            result = await this.platformGetAllUTXOs(addrs)\n        }\n        this.utxoSet = result // we can use local copy of utxos as cache for some functions\n\n        // If the hd index is full, increment\n        let currentAddr = this.getCurrentAddress()\n        let currentAddrBuf = bintools.parseAddress(currentAddr, this.chainId)\n        let currentUtxos = result.getUTXOIDs([currentAddrBuf])\n\n        if (currentUtxos.length > 0) {\n            this.incrementIndex()\n        }\n        this.isFetchUtxo = false\n        return result\n    }\n\n    // Returns more addresses than the current index\n    getExtendedAddresses() {\n        let hdIndex = this.hdIndex\n        return this.getAllDerivedAddresses(hdIndex + INDEX_RANGE)\n    }\n\n    async getAtomicUTXOs() {\n        let addrs: string[] = this.getAllDerivedAddresses()\n\n        let result = await getAtomicUTXOsForAddresses(addrs, this.chainId)\n        return result\n        // // console.log(addrs);\n        // if (this.chainId === 'P') {\n        //     let result: PlatformUTXOSet = (await pChain.getUTXOs(addrs, avm.getBlockchainID()))\n        //         .utxos\n        //     return result\n        // } else {\n        //     let result: AVMUTXOSet = (await avm.getUTXOs(addrs, pChain.getBlockchainID())).utxos\n        //\n        //     let resultC: AVMUTXOSet = (await avm.getUTXOs(addrs, cChain.getBlockchainID())).utxos\n        //     return result.merge(resultC)\n        // }\n    }\n\n    // Not used?\n    getUtxos(): AVMUTXOSet | PlatformUTXOSet {\n        return this.utxoSet\n    }\n\n    // Updates the helper keychain to contain keys upto the HD Index\n    updateKeychain(): AVMKeyChain | PlatformVMKeyChain {\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        let keychain: AVMKeyChain | PlatformVMKeyChain\n\n        if (this.chainId === 'X') {\n            keychain = new AVMKeyChain(hrp, this.chainId)\n        } else {\n            keychain = new PlatformVMKeyChain(hrp, this.chainId)\n        }\n\n        for (let i: number = 0; i <= this.hdIndex; i++) {\n            let key: AVMKeyPair | PlatformVMKeyPair\n            if (this.chainId === 'X') {\n                key = this.getKeyForIndex(i) as AVMKeyPair\n                ;(keychain as AVMKeyChain).addKey(key)\n            } else {\n                key = this.getKeyForIndex(i) as PlatformVMKeyPair\n                ;(keychain as PlatformVMKeyChain).addKey(key)\n            }\n        }\n        this.keyChain = keychain\n        return keychain\n    }\n\n    getKeychain() {\n        return this.keyChain\n    }\n\n    // Returns all key pairs up to hd index\n    getAllDerivedKeys(upTo = this.hdIndex): AVMKeyPair[] | PlatformVMKeyPair[] {\n        let set: AVMKeyPair[] | PlatformVMKeyPair[] = []\n        for (var i = 0; i <= upTo; i++) {\n            if (this.chainId === 'X') {\n                let key = this.getKeyForIndex(i) as AVMKeyPair\n                ;(set as AVMKeyPair[]).push(key)\n            } else {\n                let key = this.getKeyForIndex(i) as PlatformVMKeyPair\n                ;(set as PlatformVMKeyPair[]).push(key)\n            }\n        }\n        return set\n    }\n\n    getAllDerivedAddresses(upTo = this.hdIndex, start = 0): string[] {\n        let res = []\n        for (var i = start; i <= upTo; i++) {\n            let addr = this.getAddressForIndex(i)\n            res.push(addr)\n        }\n        return res\n    }\n\n    clearCache() {\n        this.keyCache = {}\n        this.addressCache = {}\n    }\n\n    // Scans the address space of this hd path and finds the last used index using the\n    // explorer API.\n    async findAvailableIndexExplorer(startIndex = 0): Promise<number> {\n        let upTo = 512\n\n        let addrs = this.getAllDerivedAddresses(startIndex + upTo, startIndex)\n        let addrChains = await getAddressChains(addrs)\n\n        let chainID\n        if (this.chainId === 'X') {\n            chainID = avm.getBlockchainID()\n        } else {\n            chainID = pChain.getBlockchainID()\n        }\n\n        for (var i = 0; i < addrs.length - INDEX_RANGE; i++) {\n            let gapSize: number = 0\n\n            for (var n = 0; n < INDEX_RANGE; n++) {\n                let scanIndex = i + n\n                let scanAddr = addrs[scanIndex]\n\n                let rawAddr = scanAddr.split('-')[1]\n                let chains: string[] = addrChains[rawAddr]\n\n                if (!chains) {\n                    // If doesnt exist on any chain\n                    gapSize++\n                } else if (!chains.includes(chainID)) {\n                    // If doesnt exist on this chain\n                    gapSize++\n                } else {\n                    i = i + n\n                    break\n                }\n            }\n\n            // If the gap is reached return the index\n            if (gapSize === INDEX_RANGE) {\n                return startIndex + i\n            }\n        }\n\n        return await this.findAvailableIndexExplorer(startIndex + (upTo - INDEX_RANGE))\n    }\n\n    // Uses the node to find last used HD index\n    // Only used when there is no explorer API available\n    async findAvailableIndexNode(start: number = 0): Promise<number> {\n        let addrs: string[] = []\n\n        // Get keys for indexes start to start+scan_size\n        for (let i: number = start; i < start + SCAN_SIZE; i++) {\n            let address = this.getAddressForIndex(i)\n            addrs.push(address)\n        }\n\n        let utxoSet\n\n        if (this.chainId === 'X') {\n            utxoSet = (await avm.getUTXOs(addrs)).utxos\n        } else {\n            utxoSet = (await pChain.getUTXOs(addrs)).utxos\n        }\n\n        // Scan UTXOs of these indexes and try to find a gap of INDEX_RANGE\n        for (let i: number = 0; i < addrs.length - INDEX_RANGE; i++) {\n            let gapSize: number = 0\n            // console.log(`Scan index: ${this.chainId} ${this.changePath}/${i+start}`);\n            for (let n: number = 0; n < INDEX_RANGE; n++) {\n                let scanIndex: number = i + n\n                let addr: string = addrs[scanIndex]\n                let addrBuf = bintools.parseAddress(addr, this.chainId)\n                let addrUTXOs: string[] = utxoSet.getUTXOIDs([addrBuf])\n                if (addrUTXOs.length === 0) {\n                    gapSize++\n                } else {\n                    // Potential improvement\n                    i = i + n\n                    break\n                }\n            }\n\n            // If we found a gap of 20, we can return the last fullIndex+1\n            if (gapSize === INDEX_RANGE) {\n                let targetIndex = start + i\n                return targetIndex\n            }\n        }\n        return await this.findAvailableIndexNode(start + SCAN_RANGE)\n    }\n\n    getFirstAvailableIndex(): number {\n        for (var i = 0; i < this.hdIndex; i++) {\n            let addr = this.getAddressForIndex(i)\n            let addrBuf = bintools.parseAddress(addr, this.chainId)\n            let utxoIds = this.utxoSet.getUTXOIDs([addrBuf])\n            if (utxoIds.length === 0) {\n                return i\n            }\n        }\n\n        return 0\n    }\n\n    // Returns the key of the first index that has no utxos\n    getFirstAvailableAddress(): string {\n        const idx = this.getFirstAvailableIndex()\n        return this.getAddressForIndex(idx)\n    }\n\n    getCurrentKey(): AVMKeyPair | PlatformVMKeyPair {\n        let index: number = this.hdIndex\n        return this.getKeyForIndex(index)\n    }\n\n    getCurrentAddress(): string {\n        let index = this.hdIndex\n        return this.getAddressForIndex(index)\n    }\n\n    // TODO: Public wallet should never be using this\n    getKeyForIndex(index: number, isPrivate: boolean = true): AVMKeyPair | PlatformVMKeyPair {\n        // If key is cached return that\n        let cacheExternal: AVMKeyPair | PlatformVMKeyPair\n\n        if (this.chainId === 'X') {\n            cacheExternal = this.keyCache[index] as AVMKeyPair\n        } else {\n            cacheExternal = this.keyCache[index] as PlatformVMKeyPair\n        }\n\n        if (cacheExternal) return cacheExternal\n\n        let derivationPath: string = `${this.changePath}/${index.toString()}`\n\n        // Get key from cache, if not generate it\n        let key: HDKey\n        if (this.hdCache[index]) {\n            key = this.hdCache[index]\n        } else {\n            key = this.masterKey.derive(derivationPath) as HDKey\n            this.hdCache[index] = key\n        }\n\n        let pkHex: string\n        if (!this.isPublic) {\n            pkHex = key.privateKey.toString('hex')\n        } else {\n            pkHex = key.publicKey.toString('hex')\n        }\n\n        let pkBuf: Buffer = new Buffer(pkHex, 'hex')\n        let keypair = this.keyChain.importKey(pkBuf)\n\n        // save to cache\n        this.keyCache[index] = keypair\n        return keypair\n    }\n\n    getAddressForIndex(index: number): string {\n        if (this.addressCache[index]) {\n            return this.addressCache[index]\n        }\n\n        let derivationPath: string = `${this.changePath}/${index.toString()}`\n        // let key: HDKey = this.masterKey.derive(derivationPath) as HDKey;\n\n        // Get key from cache, if not generate it\n        let key: HDKey\n        if (this.hdCache[index]) {\n            key = this.hdCache[index]\n        } else {\n            key = this.masterKey.derive(derivationPath) as HDKey\n            this.hdCache[index] = key\n        }\n\n        let pkHex = key.publicKey.toString('hex')\n        let pkBuff = Buffer.from(pkHex, 'hex')\n        let hrp = getPreferredHRP(ava.getNetworkID())\n\n        let chainId = this.chainId\n\n        // No need for PlatformKeypair because addressToString uses chainID to decode\n        let keypair = new AVMKeyPair(hrp, chainId)\n        let addrBuf = keypair.addressFromPublicKey(pkBuff)\n        let addr = bintools.addressToString(hrp, chainId, addrBuf)\n\n        this.addressCache[index] = addr\n        return addr\n    }\n\n    // Given an address find the derived index\n    findAddressIndex(addr: string): number | null {\n        let addrs = this.getAllDerivedAddresses()\n        let index = addrs.indexOf(addr)\n\n        if (index < 0) return null\n        return index\n    }\n}\nexport { HdHelper }\n","import { AvaWalletCore, ChainAlias } from '@/js/wallets/IAvaHdWallet'\nimport {\n    AssetAmountDestination,\n    BaseTx,\n    MinterSet,\n    NFTMintOutput,\n    TransferableInput,\n    TransferableOutput,\n    Tx,\n    UnsignedTx,\n    UTXO,\n    UTXOSet,\n} from 'avalanche/dist/apis/avm'\n\nimport { BN, Buffer } from 'avalanche'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { ava, avm, bintools, pChain } from '@/AVA'\nimport { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport HDKey from 'hdkey'\nimport { HdHelper } from '@/js/HdHelper'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm/utxos'\nimport createHash from 'create-hash'\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { OutputOwners } from 'avalanche/dist/common'\nimport { buildCreateNftFamilyTx, buildMintNftTx, buildUnsignedTransaction } from '../TxHelper'\nvar uniqid = require('uniqid')\n\n// A base class other HD wallets are based on.\n// Mnemonic Wallet and LedgerWallet uses this\n\nclass HdWalletCore {\n    id: string\n    chainId: string\n    utxoset: UTXOSet\n    platformUtxoset: PlatformUTXOSet\n    stakeAmount: BN\n\n    internalHelper: HdHelper\n    externalHelper: HdHelper\n    platformHelper: HdHelper\n    isFetchUtxos: boolean // true if fetching utxos\n    isInit: boolean\n\n    constructor(accountHdKey: HDKey, isPublic = true) {\n        this.id = uniqid()\n        this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID()\n        this.utxoset = new AVMUTXOSet()\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.stakeAmount = new BN(0)\n        this.isFetchUtxos = false\n        this.isInit = false\n        this.externalHelper = new HdHelper('m/0', accountHdKey, undefined, isPublic)\n        this.internalHelper = new HdHelper('m/1', accountHdKey, undefined, isPublic)\n        this.platformHelper = new HdHelper('m/0', accountHdKey, 'P', isPublic)\n\n        this.externalHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n        this.internalHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n        this.platformHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n    }\n\n    getUTXOSet(): AVMUTXOSet {\n        return this.utxoset\n    }\n\n    updateAvmUTXOSet(): void {\n        // if (this.isFetchUtxos) return\n        let setExternal = this.externalHelper.utxoSet as AVMUTXOSet\n        let setInternal = this.internalHelper.utxoSet as AVMUTXOSet\n\n        let joined = setInternal.merge(setExternal)\n        this.utxoset = joined\n    }\n\n    // TODO: This function can be moved to a Core wallet class\n    async buildCreateNftFamilyTx(\n        name: string,\n        symbol: string,\n        groupNum: number = 1\n    ): Promise<UnsignedTx> {\n        let fromAddresses = this.getDerivedAddresses()\n        let changeAddress = this.getChangeAddress()\n\n        let minterAddress = this.getCurrentAddress()\n\n        let unsignedTx = await buildCreateNftFamilyTx(\n            name,\n            symbol,\n            groupNum,\n            fromAddresses,\n            minterAddress,\n            changeAddress,\n            this.utxoset\n        )\n\n        // const minterSets: MinterSet[] = []\n        //\n        // // Create the groups\n        // for (var i = 0; i < groupNum; i++) {\n        //     const minterSet: MinterSet = new MinterSet(1, [minterAddress])\n        //     minterSets.push(minterSet)\n        // }\n        //\n        // let utxoSet: UTXOSet = this.utxoset\n        //\n        // let unsignedTx: UnsignedTx = await avm.buildCreateNFTAssetTx(\n        //     utxoSet,\n        //     fromAddresses,\n        //     [changeAddress],\n        //     minterSets,\n        //     name,\n        //     symbol\n        // )\n\n        return unsignedTx\n    }\n\n    // TODO: Can be moved to a core wallet class\n    async buildMintNftTx(\n        mintUtxo: UTXO,\n        payload: PayloadBase,\n        quantity: number,\n        ownerAddress: string,\n        changeAddress: string\n    ): Promise<UnsignedTx> {\n        let sourceAddresses = this.getDerivedAddresses()\n\n        let mintTx = buildMintNftTx(\n            mintUtxo,\n            payload,\n            quantity,\n            ownerAddress,\n            changeAddress,\n            sourceAddresses,\n            this.utxoset\n        )\n\n        return mintTx\n    }\n\n    updateFetchState() {\n        this.isFetchUtxos =\n            this.externalHelper.isFetchUtxo ||\n            this.internalHelper.isFetchUtxo ||\n            this.platformHelper.isFetchUtxo\n    }\n\n    updateInitState() {\n        this.isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n    }\n    // Fetches the utxos\n    async getUTXOs(): Promise<void> {\n        this.internalHelper.updateUtxos().then((utxoSet) => {\n            this.updateFetchState()\n            this.updateAvmUTXOSet()\n        })\n\n        this.externalHelper.updateUtxos().then((utxoSet) => {\n            this.updateFetchState()\n            this.updateAvmUTXOSet()\n        })\n\n        // let setInternal = (await this.internalHelper.updateUtxos()) as AVMUTXOSet\n        // let setExternal = (await this.externalHelper.updateUtxos()) as AVMUTXOSet\n        // platform utxos are updated but not returned by function\n        this.platformHelper.updateUtxos().then((utxoSet) => {\n            this.updateFetchState()\n        })\n\n        this.getStake()\n        // let joined = setInternal.merge(setExternal)\n        // this.utxoset = joined\n        // return joined\n        return\n    }\n\n    getAllDerivedExternalAddresses(): string[] {\n        return this.externalHelper.getAllDerivedAddresses()\n    }\n\n    getDerivedAddresses(): string[] {\n        let internal = this.internalHelper.getAllDerivedAddresses()\n        let external = this.externalHelper.getAllDerivedAddresses()\n        return internal.concat(external)\n    }\n\n    getDerivedAddressesP(): string[] {\n        return this.platformHelper.getAllDerivedAddresses()\n    }\n\n    getAllAddressesX() {\n        return this.getDerivedAddresses()\n    }\n\n    getAllAddressesP() {\n        return this.getDerivedAddressesP()\n    }\n    // Returns addresses to check for history\n    getHistoryAddresses(): string[] {\n        let internalIndex = this.internalHelper.hdIndex\n        // They share the same address space, so whatever has the highest index\n        let externalIndex = Math.max(this.externalHelper.hdIndex, this.platformHelper.hdIndex)\n\n        let internal = this.internalHelper.getAllDerivedAddresses(internalIndex)\n        let external = this.externalHelper.getAllDerivedAddresses(externalIndex)\n        return internal.concat(external)\n    }\n\n    getExtendedPlatformAddresses(): string[] {\n        let index = this.platformHelper.hdIndex\n        let addrs = this.platformHelper.getAllDerivedAddresses(index + 20)\n        return addrs\n    }\n\n    getCurrentAddress(): string {\n        return this.externalHelper.getCurrentAddress()\n    }\n\n    getChangeAddress(chainId?: ChainAlias): string {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.getCurrentAddress()\n            case 'X':\n            default:\n                return this.internalHelper.getCurrentAddress()\n        }\n    }\n\n    getChangePath(chainId?: ChainAlias): string {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.changePath\n            case 'X':\n            default:\n                return this.internalHelper.changePath\n        }\n    }\n\n    getChangeIndex(chainId?: ChainAlias): number {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.hdIndex\n            case 'X':\n            default:\n                return this.internalHelper.hdIndex\n        }\n    }\n\n    getChangeFromIndex(idx?: number, chainId?: ChainAlias): string | null {\n        if (idx === undefined || idx === null) return null\n\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.getAddressForIndex(idx)\n            case 'X':\n            default:\n                return this.internalHelper.getAddressForIndex(idx)\n        }\n    }\n\n    getPlatformRewardAddress(): string {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getCurrentPlatformAddress(): string {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getPlatformUTXOSet() {\n        return this.platformHelper.utxoSet as PlatformUTXOSet\n    }\n\n    getPlatformActiveIndex() {\n        return this.platformHelper.hdIndex\n    }\n\n    getExternalActiveIndex() {\n        return this.externalHelper.hdIndex\n    }\n\n    getBaseAddress() {\n        return this.externalHelper.getAddressForIndex(0)\n    }\n\n    // helper method to get all stake for more than 256 addresses\n    async getAllStake(addrs: string[]): Promise<BN> {\n        if (addrs.length <= 256) {\n            return await pChain.getStake(addrs)\n        } else {\n            //Break the list in to 1024 chunks\n            let chunk = addrs.slice(0, 256)\n            let remainingChunk = addrs.slice(256)\n\n            let chunkStake = await pChain.getStake(chunk)\n            return chunkStake.add(await this.getAllStake(remainingChunk))\n        }\n    }\n\n    async getStake(): Promise<BN> {\n        // let xIndex = Math.max(this.externalHelper.hdIndex,this.internalHelper.hdIndex);\n        // let pIndex = Math.max(this.platformHelper.hdIndex);\n        // let uptoIndex = Math.max(xIndex, pIndex);\n        let uptoIndex = this.platformHelper.hdIndex + 40\n        let addrs = this.platformHelper.getAllDerivedAddresses(uptoIndex)\n        let res = await this.getAllStake(addrs)\n        this.stakeAmount = res\n        return res\n    }\n\n    onnetworkchange(): void {\n        this.isInit = false\n        this.stakeAmount = new BN(0)\n\n        this.externalHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n        this.internalHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n        this.platformHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n\n        // TODO: Handle EVM changes\n    }\n\n    async buildUnsignedTransaction(orders: (ITransaction | UTXO)[], addr: string, memo?: Buffer) {\n        const changeAddress = this.getChangeAddress()\n        const derivedAddresses: string[] = this.getDerivedAddresses()\n        const utxoset = this.getUTXOSet()\n\n        return buildUnsignedTransaction(\n            orders,\n            addr,\n            derivedAddresses,\n            utxoset,\n            changeAddress,\n            memo\n        )\n    }\n}\nexport { HdWalletCore }\n","// interface IHistoryParsedBaseTx{\n//     sent:\n//     received:\n// }\n\nimport { ITransactionData, UTXO } from '@/store/modules/history/types'\nimport { WalletType } from '@/store/types'\nimport { BN } from 'avalanche'\nimport { AVMConstants } from 'avalanche/dist/apis/avm'\n\n// Summary item returned for each transaction\nexport interface BaseTxSummary {\n    tokens: {\n        [assetId: string]: BaseTxAssetSummary\n    }\n    collectibles: BaseTxNFTSummary\n}\n\ninterface TokenSummaryResult {\n    [assetID: string]: BaseTxAssetSummary\n}\n\nexport interface BaseTxNFTSummary {\n    received: NFTSummaryResultDict\n    sent: NFTSummaryResultDict\n}\n\ninterface NFTSummaryResultDict {\n    assets: {\n        [assetID: string]: UTXO[]\n    }\n    addresses: string[]\n}\n\n// export interface BaseTxNFTSummary {\n//     sent: UTXO[]\n//     received: UTXO[]\n// }\n\nexport interface BaseTxAssetSummary {\n    amount: BN\n    payload: string | undefined\n    groupNum: number\n    addresses: string[]\n}\n\n// Used with tokens\nfunction addToDict(\n    assetId: string,\n    amount: BN,\n    dict: TokenSummaryResult,\n    utxo: UTXO,\n    addresses: string[]\n) {\n    if (dict[assetId]) {\n        dict[assetId].amount = dict[assetId].amount.add(amount)\n\n        let addrDiff = addresses.filter((addr) => !dict[assetId].addresses.includes(addr))\n        dict[assetId].addresses.push(...addrDiff)\n    } else {\n        dict[assetId] = {\n            amount: amount,\n            payload: utxo.payload,\n            groupNum: utxo.groupID,\n            addresses: addresses,\n        }\n    }\n}\n\nfunction getNFTsSummary(tx: ITransactionData, wallet: WalletType): BaseTxNFTSummary {\n    let nftLoss = getLossNFT(tx, wallet)\n    let nftGain = getGainNFT(tx, wallet)\n    return {\n        sent: nftLoss,\n        received: nftGain,\n    }\n}\n\nfunction getLossNFT(tx: ITransactionData, wallet: WalletType): NFTSummaryResultDict {\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let inputs = tx.inputs || []\n    let outputs = tx.outputs\n\n    let loss: NFTSummaryResultDict = {\n        assets: {},\n        addresses: [],\n    }\n\n    let nfts = inputs.filter((input) => {\n        let type = input.output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    let nftsOuts = outputs.filter((output) => {\n        let type = output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    for (var i = 0; i < nfts.length; i++) {\n        let utxo = nfts[i].output\n        let owners = utxo.addresses\n        let assetID = utxo.assetID\n\n        let intersect = owners.filter((addr) => addrsStripped.includes(addr))\n\n        // Did we lose it?\n        if (intersect.length > 0) {\n            if (loss.assets[assetID]) {\n                loss.assets[assetID].push(utxo)\n            } else {\n                loss.assets[assetID] = [utxo]\n            }\n\n            // Who did we lose it to?\n            for (var n = 0; i < nftsOuts.length; n++) {\n                let nftOut = nftsOuts[n]\n                let doesMatch = nftOut.groupID === utxo.groupID && nftOut.assetID === utxo.assetID\n                let addrNotAdded = nftOut.addresses.filter((addr) => !loss.addresses.includes(addr))\n                if (doesMatch) {\n                    loss.addresses.push(...addrNotAdded)\n                    break\n                }\n            }\n        }\n    }\n\n    return loss\n}\n\nfunction getGainNFT(tx: ITransactionData, wallet: WalletType): NFTSummaryResultDict {\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let inputs = tx.inputs || []\n    let outputs = tx.outputs\n\n    let gain: NFTSummaryResultDict = {\n        assets: {},\n        addresses: [],\n    }\n\n    let nftsIns = inputs.filter((input) => {\n        let type = input.output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    let nftsOuts = outputs.filter((output) => {\n        let type = output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    for (var i = 0; i < nftsOuts.length; i++) {\n        let utxo = nftsOuts[i]\n        let owners = utxo.addresses\n        let assetID = utxo.assetID\n\n        let intersect = owners.filter((addr) => addrsStripped.includes(addr))\n\n        // Did we gain it?\n        if (intersect.length > 0) {\n            if (gain.assets[assetID]) {\n                gain.assets[assetID].push(utxo)\n            } else {\n                gain.assets[assetID] = [utxo]\n            }\n\n            // Who did we gain it from?\n            for (var n = 0; n < nftsIns.length; n++) {\n                let nftIn = nftsIns[n].output\n                let doesMatch = nftIn.groupID === utxo.groupID && nftIn.assetID === utxo.assetID\n                let addrNotAdded = nftIn.addresses.filter((addr) => !gain.addresses.includes(addr))\n                if (doesMatch) {\n                    gain.addresses.push(...addrNotAdded)\n                }\n            }\n        }\n    }\n\n    return gain\n}\n\nfunction getLoss(tx: ITransactionData, wallet: WalletType): TokenSummaryResult {\n    let ins = tx.inputs || []\n    let outs = tx.outputs\n\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let loss: TokenSummaryResult = {}\n\n    if (ins) {\n        for (let i = 0; i < ins.length; i++) {\n            let input = ins[i]\n            let utxo = input.output\n            let outputType = utxo.outputType\n            let isNft = outputType === AVMConstants.NFTXFEROUTPUTID\n\n            if (isNft) continue\n\n            let addrs = utxo.addresses\n\n            let intersect = addrs.filter((addr) => addrsStripped.includes(addr))\n\n            if (intersect.length === 0) continue\n\n            let assetId = utxo.assetID\n            let amount = utxo.amount\n            let amountBN = new BN(amount)\n\n            // Get who received this asset\n            let receivers: string[] = []\n            outs.forEach((utxo) => {\n                if (utxo.assetID === assetId) {\n                    let outAddrs = utxo.addresses\n                    // If not a wallet address and not added to receivers\n                    let targets = outAddrs.filter(\n                        (addr: string) => !addrsStripped.includes(addr) && !receivers.includes(addr)\n                    )\n                    receivers.push(...targets)\n                }\n            })\n\n            addToDict(assetId, amountBN, loss, utxo, receivers)\n        }\n    }\n\n    return loss\n}\n\nfunction getProfit(tx: ITransactionData, wallet: WalletType): TokenSummaryResult {\n    let outs = tx.outputs\n    let ins = tx.inputs || []\n\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let profit: TokenSummaryResult = {}\n\n    if (outs) {\n        for (let i = 0; i < outs.length; i++) {\n            let utxo = outs[i]\n            let outputType = utxo.outputType\n            let isNft = outputType === AVMConstants.NFTXFEROUTPUTID\n\n            // Skip NFTs\n            if (isNft) continue\n\n            let addrs = utxo.addresses\n\n            let intersect = addrs.filter((addr) => addrsStripped.includes(addr))\n\n            if (intersect.length === 0) continue\n\n            let assetId = utxo.assetID\n            let amount = utxo.amount\n            let amountBN = new BN(amount)\n\n            // Get who sent this to you\n            let senders: string[] = []\n            ins.forEach((input) => {\n                let utxo = input.output\n                if (utxo.assetID === assetId) {\n                    let outAddrs = utxo.addresses\n                    // If not a wallet address and not added to senders\n                    let targets = outAddrs.filter(\n                        (addr: string) => !addrsStripped.includes(addr) && !senders.includes(addr)\n                    )\n                    senders.push(...targets)\n                }\n            })\n\n            addToDict(assetId, amountBN, profit, utxo, senders)\n        }\n    }\n\n    return profit\n}\n\n// Finds the absolute gains and losses for the active wallet given transaction data from the explorer\nfunction getTransactionSummary(tx: ITransactionData, wallet: WalletType) {\n    let losses = getLoss(tx, wallet)\n    let profits = getProfit(tx, wallet)\n\n    let nftSummary = getNFTsSummary(tx, wallet)\n\n    // let nftLoss = getLossNFT(tx, wallet)\n    // let nftGain = getGainNFT()NFT(tx, wallet)\n    // console.log(nftLoss)\n\n    let sum: BaseTxSummary = {\n        tokens: {},\n        collectibles: {\n            sent: nftSummary.sent,\n            received: nftSummary.received,\n        },\n    }\n\n    // First the losses\n    for (let assetId in losses) {\n        let loss = losses[assetId]\n\n        sum.tokens[assetId] = {\n            amount: loss.amount.mul(new BN(-1)),\n            payload: loss.payload,\n            groupNum: loss.groupNum,\n            addresses: loss.addresses,\n        }\n    }\n\n    for (let assetId in profits) {\n        let profit = profits[assetId]\n\n        if (sum.tokens[assetId]) {\n            sum.tokens[assetId].amount = sum.tokens[assetId].amount.add(profit.amount)\n        } else {\n            sum.tokens[assetId] = {\n                amount: profit.amount,\n                payload: profit.payload,\n                groupNum: profit.groupNum,\n                addresses: profit.addresses,\n            }\n        }\n    }\n\n    return sum\n}\n\nexport { getTransactionSummary }\n","// import AppBtc from \"@ledgerhq/hw-app-btc\";\n//@ts-ignore\nimport AppAvax from '@obsidiansystems/hw-app-avalanche'\n\nimport moment from 'moment'\nimport { Buffer, BN } from 'avalanche'\nimport HDKey from 'hdkey'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nvar bippath = require('bip32-path')\nimport createHash from 'create-hash'\nimport store from '@/store'\n\nimport { UTXO, UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport { AvaWalletCore, ChainAlias } from '@/js/wallets/IAvaHdWallet'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport {\n    AVMConstants,\n    OperationTx,\n    SelectCredentialClass,\n    TransferableOperation,\n    TransferableOutput as AVMTransferableOutput,\n    Tx as AVMTx,\n    UnsignedTx as AVMUnsignedTx,\n} from 'avalanche/dist/apis/avm'\n\nimport {\n    ImportTx,\n    ExportTx,\n    TransferableOutput as PlatformTransferableOutput,\n    Tx as PlatformTx,\n    UTXO as PlatformUTXO,\n    UnsignedTx as PlatformUnsignedTx,\n    UTXOSet as PlatformUTXOSet,\n    PlatformVMConstants,\n} from 'avalanche/dist/apis/platformvm'\n\nimport { Credential, SigIdx, Signature } from 'avalanche/dist/common'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\nimport { HdWalletCore } from '@/js/wallets/HdWalletCore'\nimport { ILedgerAppConfig, WalletNameType } from '@/store/types'\nimport { bnToBig, digestMessage } from '@/helpers/helper'\nimport { web3 } from '@/evm'\nimport { AVA_ACCOUNT_PATH } from './AvaHdWallet'\nimport { ChainIdType } from '@/constants'\nimport { ParseableAvmTxEnum, ParseablePlatformEnum } from '../TxHelper'\nimport { ILedgerBlockMessage } from '../../store/modules/ledger/types'\n\nclass LedgerWallet extends HdWalletCore implements AvaWalletCore {\n    app: AppAvax\n    type: WalletNameType\n\n    ethAddress: string\n    ethBalance: BN\n    ethAddressBech: string\n    config: ILedgerAppConfig\n\n    constructor(app: AppAvax, hdkey: HDKey, config: ILedgerAppConfig) {\n        super(hdkey)\n        this.app = app\n        this.type = 'ledger'\n        this.config = config\n\n        // TODO: Add actual values\n        this.ethAddress = ''\n        this.ethBalance = new BN(0)\n        this.ethAddressBech = ''\n    }\n\n    static async fromApp(app: AppAvax, config: ILedgerAppConfig) {\n        let res = await app.getWalletExtendedPublicKey(AVA_ACCOUNT_PATH)\n\n        let hd = new HDKey()\n        hd.publicKey = res.public_key\n        hd.chainCode = res.chain_code\n\n        return new LedgerWallet(app, hd, config)\n    }\n\n    // Returns an array of derivation paths that need to sign this transaction\n    // Used with signTransactionHash and signTransactionParsable\n    getTransactionPaths<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        isAVM: boolean = true\n    ): { paths: string[]; isAvaxOnly: boolean } {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        let ins = tx.getIns()\n        let operations: TransferableOperation[] = []\n\n        // Try to get operations, it will fail if there are none, ignore and continue\n        try {\n            operations = (tx as OperationTx).getOperations()\n        } catch (e) {\n            console.log(e)\n        }\n\n        let items = ins\n        if (txType === AVMConstants.IMPORTTX || txType === PlatformVMConstants.IMPORTTX) {\n            items = (tx as ImportTx).getImportInputs()\n        }\n\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        let chainId = isAVM ? 'X' : 'P'\n\n        let paths: string[] = []\n\n        let isAvaxOnly = true\n        // Collect paths derivation paths for source addresses\n        for (let i = 0; i < items.length; i++) {\n            let item = items[i]\n\n            let assetId = bintools.cb58Encode(item.getAssetID())\n            // @ts-ignore\n            if (assetId !== store.state.Assets.AVA_ASSET_ID) {\n                isAvaxOnly = false\n            }\n\n            let sigidxs: SigIdx[] = item.getInput().getSigIdxs()\n            let sources = sigidxs.map((sigidx) => sigidx.getSource())\n            let addrs: string[] = sources.map((source) => {\n                return bintools.addressToString(hrp, chainId, source)\n            })\n\n            for (let j = 0; j < addrs.length; j++) {\n                let srcAddr = addrs[j]\n                let pathStr = this.getPathFromAddress(srcAddr) // returns change/index\n\n                paths.push(pathStr)\n            }\n        }\n\n        // Do the Same for operational inputs, if there are any...\n        for (let i = 0; i < operations.length; i++) {\n            let op = operations[i]\n            let sigidxs: SigIdx[] = op.getOperation().getSigIdxs()\n            let sources = sigidxs.map((sigidx) => sigidx.getSource())\n            let addrs: string[] = sources.map((source) => {\n                return bintools.addressToString(hrp, chainId, source)\n            })\n\n            for (let j = 0; j < addrs.length; j++) {\n                let srcAddr = addrs[j]\n                let pathStr = this.getPathFromAddress(srcAddr) // returns change/index\n\n                paths.push(pathStr)\n            }\n        }\n\n        return { paths, isAvaxOnly }\n    }\n\n    pathsToUniqueBipPaths(paths: string[]) {\n        let uniquePaths = paths.filter((val: any, i: number) => {\n            return paths.indexOf(val) === i\n        })\n\n        let bip32Paths = uniquePaths.map((path) => {\n            return bippath.fromString(path, false)\n        })\n\n        return bip32Paths\n    }\n\n    getChangeBipPath<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainAlias\n    ) {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        const chainChangePath = this.getChangePath(chainId).split('m/')[1]\n        let changeIdx = this.getChangeIndex(chainId)\n        // If change and destination paths are the same\n        // it can cause ledger to not display the destination amt.\n        // Since platform helper does not have internal/external\n        // path for change (it uses the next address)\n        // there can be an address collisions.\n        if (\n            (txType === PlatformVMConstants.IMPORTTX || txType === PlatformVMConstants.EXPORTTX) &&\n            this.platformHelper.hdIndex === this.externalHelper.hdIndex\n        ) {\n            return null\n        } else if (\n            txType === PlatformVMConstants.ADDVALIDATORTX ||\n            txType === PlatformVMConstants.ADDDELEGATORTX\n        ) {\n            changeIdx = this.platformHelper.getFirstAvailableIndex()\n        }\n\n        return bippath.fromString(`${AVA_ACCOUNT_PATH}/${chainChangePath}/${changeIdx}`)\n    }\n\n    getCredentials<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        paths: string[],\n        sigMap: any\n    ): Credential[] {\n        let creds: Credential[] = []\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        let ins = tx.getIns()\n\n        let items = ins\n        if (txType === AVMConstants.IMPORTTX || txType === PlatformVMConstants.IMPORTTX) {\n            items = (tx as ImportTx).getImportInputs()\n        }\n\n        let operations: TransferableOperation[] = []\n\n        // Try to get operations, it will fail if there are none, ignore and continue\n        try {\n            operations = (tx as OperationTx).getOperations()\n        } catch (e) {\n            console.log(e)\n        }\n\n        for (let i = 0; i < items.length; i++) {\n            const sigidxs: SigIdx[] = items[i].getInput().getSigIdxs()\n            const cred: Credential = SelectCredentialClass(items[i].getInput().getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                let pathIndex = i + j\n                let pathStr = paths[pathIndex]\n\n                let sigRaw = sigMap.get(pathStr)\n                let sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        for (let i = 0; i < operations.length; i++) {\n            let op = operations[i].getOperation()\n            const sigidxs: SigIdx[] = op.getSigIdxs()\n            const cred: Credential = SelectCredentialClass(op.getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                let pathIndex = items.length + i + j\n                let pathStr = paths[pathIndex]\n\n                let sigRaw = sigMap.get(pathStr)\n                let sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        return creds\n    }\n\n    // Used for non parsable transactions.\n    // Ideally we wont use this function at all, but ledger is not ready yet.\n    async signTransactionHash<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx\n    >(unsignedTx: UnsignedTx, paths: string[], isAVM: boolean = true): Promise<SignedTx> {\n        let txbuff = unsignedTx.toBuffer()\n        const msg: Buffer = Buffer.from(createHash('sha256').update(txbuff).digest())\n\n        try {\n            store.commit('Ledger/openModal', {\n                title: 'Sign Hash',\n                messages: [],\n                info: msg.toString('hex').toUpperCase(),\n            })\n\n            let bip32Paths = this.pathsToUniqueBipPaths(paths)\n\n            // Sign the msg with ledger\n            const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n            let sigMap = await this.app.signHash(accountPath, bip32Paths, msg)\n            store.commit('Ledger/closeModal')\n\n            let sigs: Credential[] = this.getCredentials<UnsignedTx>(unsignedTx, paths, sigMap)\n\n            let signedTx\n            if (isAVM) {\n                signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, sigs)\n            } else {\n                signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, sigs)\n            }\n            return signedTx as SignedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.log(e)\n            throw e\n        }\n    }\n\n    // Used for signing transactions that are parsable\n    async signTransactionParsable<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx\n    >(unsignedTx: UnsignedTx, paths: string[], isAVM: boolean = true): Promise<SignedTx> {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let chainId: ChainAlias = isAVM ? 'X' : 'P'\n        let parseableTxs = chainId === 'X' ? ParseableAvmTxEnum : ParseablePlatformEnum\n\n        let title = `Sign ${parseableTxs[txType]}`\n\n        let bip32Paths = this.pathsToUniqueBipPaths(paths)\n\n        const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n        let txbuff = unsignedTx.toBuffer()\n        let changePath = this.getChangeBipPath(unsignedTx, chainId)\n        let messages = this.getTransactionMessages<UnsignedTx>(unsignedTx, isAVM, changePath)\n\n        try {\n            store.commit('Ledger/openModal', {\n                title: title,\n                messages: messages,\n                info: null,\n            })\n\n            let ledgerSignedTx = await this.app.signTransaction(\n                accountPath,\n                bip32Paths,\n                txbuff,\n                changePath\n            )\n            let sigMap = ledgerSignedTx.signatures\n\n            let creds = this.getCredentials<UnsignedTx>(unsignedTx, paths, sigMap)\n\n            let signedTx\n            if (isAVM) {\n                signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds)\n            } else {\n                signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds)\n            }\n            return signedTx as SignedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.log(e)\n            throw e\n        }\n    }\n\n    getOutputMessages<Outputs extends AVMTransferableOutput[] | PlatformTransferableOutput[]>(\n        outs: Outputs,\n        isAVM: boolean,\n        changePath: null | { toPathArray: () => number[] }\n    ): ILedgerBlockMessage[] {\n        let messages: ILedgerBlockMessage[] = []\n        let chainId: ChainAlias = isAVM ? 'X' : 'P'\n        let hrp = getPreferredHRP(ava.getNetworkID())\n\n        let changeIdx = changePath?.toPathArray()[changePath?.toPathArray().length - 1]\n        let changeAddr = this.getChangeFromIndex(changeIdx, chainId)\n\n        for (let i = 0; i < outs.length; i++) {\n            outs[i]\n                .getOutput()\n                .getAddresses()\n                .forEach((value) => {\n                    const addr = bintools.addressToString(hrp, chainId, value)\n                    // @ts-ignore\n                    const amt = bnToBig(outs[i].getOutput().getAmount(), 9)\n\n                    if (!changePath || changeAddr !== addr)\n                        messages.push({\n                            title: 'Output',\n                            value: `${addr} - ${amt.toString()} AVAX`,\n                        })\n                })\n        }\n\n        return messages\n    }\n\n    // Given the unsigned transaction returns an array of messages that will be displayed on ledgegr window\n    getTransactionMessages<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        isAVM: boolean = true,\n        changePath: null | { toPathArray: () => number[] }\n    ): ILedgerBlockMessage[] {\n        let messages: ILedgerBlockMessage[] = []\n\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let outs = tx.getOuts()\n        let outputMessages = this.getOutputMessages(outs, isAVM, changePath)\n\n        // regular output messages, if any\n        messages.push(...outputMessages)\n\n        if (txType === AVMConstants.EXPORTTX || txType === PlatformVMConstants.EXPORTTX) {\n            outs = (tx as ExportTx).getExportOutputs()\n            // export output messages, if any\n            outputMessages = this.getOutputMessages(outs, isAVM, changePath)\n            messages.push(...outputMessages)\n        }\n\n        // TODO: Construct the messages array depending on transaction type\n        if (\n            txType === PlatformVMConstants.ADDDELEGATORTX ||\n            txType === PlatformVMConstants.ADDVALIDATORTX\n        ) {\n            const format = 'YYYY-MM-DD H:mm:ss UTC'\n            // @ts-ignore\n            const nodeID = bintools.cb58Encode(tx.nodeID)\n            // @ts-ignore\n            const startTime = moment(parseInt(tx.getStartTime()) * 1000)\n                .utc()\n                .format(format)\n            // @ts-ignore\n            const endTime = moment(parseInt(tx.getEndTime()) * 1000)\n                .utc()\n                .format(format)\n            // @ts-ignore\n            const stakeAmt = bnToBig(tx.getStakeAmount(), 9)\n            messages.push({ title: 'NodeID', value: nodeID })\n            messages.push({ title: 'Start Time', value: startTime })\n            messages.push({ title: 'End Time', value: endTime })\n            messages.push({ title: 'Total Stake', value: `${stakeAmt} AVAX` })\n            messages.push({\n                title: 'Stake',\n                value: `${stakeAmt} to ${this.platformHelper.getCurrentAddress()}`,\n            })\n            messages.push({\n                title: 'Reward to',\n                value: `${this.platformHelper.getCurrentAddress()}`,\n            })\n            // @ts-ignore\n            if (tx.delegationFee) {\n                // @ts-ignore\n                messages.push({ title: 'Delegation Fee', value: `${tx.delegationFee}%` })\n            }\n            messages.push({ title: 'Fee', value: '0' })\n        }\n        if (\n            txType === AVMConstants.EXPORTTX ||\n            txType === AVMConstants.IMPORTTX ||\n            txType === PlatformVMConstants.EXPORTTX ||\n            txType === PlatformVMConstants.IMPORTTX ||\n            txType === AVMConstants.BASETX\n        ) {\n            messages.push({ title: 'Fee', value: `${0.001} AVAX` })\n        }\n\n        return messages\n    }\n\n    async sign<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx\n    >(unsignedTx: UnsignedTx, isAVM: boolean = true): Promise<SignedTx> {\n        // Check if transaction can be parsed by ledger\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let chainId = isAVM ? 'X' : 'P'\n\n        let parseableTxs = chainId === 'X' ? ParseableAvmTxEnum : ParseablePlatformEnum\n\n        let { paths, isAvaxOnly } = this.getTransactionPaths<UnsignedTx>(unsignedTx, isAVM)\n        // If ledger doesnt support parsing, sign hash\n        let canLedgerParse = this.config.version >= '0.3.1'\n        let isParsableType = txType in parseableTxs && isAvaxOnly\n\n        let signedTx\n        if (canLedgerParse && isParsableType) {\n            signedTx = await this.signTransactionParsable<UnsignedTx, SignedTx>(\n                unsignedTx,\n                paths,\n                isAVM\n            )\n        } else {\n            signedTx = await this.signTransactionHash<UnsignedTx, SignedTx>(\n                unsignedTx,\n                paths,\n                isAVM\n            )\n        }\n\n        store.commit('Ledger/closeModal')\n\n        return signedTx\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    async getEthBalance() {\n        console.error('Not implemented')\n        // let bal = await web3.eth.getBalance(this.ethAddress)\n        this.ethBalance = new BN(0)\n        return this.ethBalance\n    }\n\n    async getUTXOs(): Promise<void> {\n        // TODO: Move to shared file\n        this.isFetchUtxos = true\n        // If we are waiting for helpers to initialize delay the call\n        let isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n        if (!isInit) {\n            setTimeout(() => {\n                this.getUTXOs()\n            }, 1000)\n            // console.info('HD Not ready try again in 1 sec..')\n            return\n        }\n\n        super.getUTXOs()\n        this.getEthBalance()\n        return\n    }\n\n    getPathFromAddress(address: string) {\n        let externalAddrs = this.externalHelper.getExtendedAddresses()\n        let internalAddrs = this.internalHelper.getExtendedAddresses()\n        let platformAddrs = this.platformHelper.getExtendedAddresses()\n\n        let extIndex = externalAddrs.indexOf(address)\n        let intIndex = internalAddrs.indexOf(address)\n        let platformIndex = platformAddrs.indexOf(address)\n\n        if (extIndex >= 0) {\n            return `0/${extIndex}`\n        } else if (intIndex >= 0) {\n            return `1/${intIndex}`\n        } else if (platformIndex >= 0) {\n            return `0/${platformIndex}`\n        } else {\n            throw 'Unable to find source address.'\n        }\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | UTXO)[],\n        addr: string,\n        memo?: Buffer\n    ): Promise<string> {\n        let unsignedTx = await this.buildUnsignedTransaction(orders, addr, memo)\n\n        let tx = await this.sign<AVMUnsignedTx, AVMTx>(unsignedTx)\n        const txId: string = await avm.issueTx(tx)\n\n        // TODO: Must update index after sending a tx\n        // TODO: Index will not increase but it could decrease.\n        // TODO: With the current setup this can lead to gaps in index space greater than scan size.\n        setTimeout(async () => {\n            // Find the new HD index\n            this.internalHelper.findHdIndex()\n            this.externalHelper.findHdIndex()\n            this.platformHelper.findHdIndex()\n        }, 2000)\n\n        return txId\n    }\n\n    async chainTransfer(amt: BN, sourceChain: string = 'X'): Promise<string> {\n        let fee = avm.getTxFee()\n        let amtFee = amt.add(fee)\n\n        // EXPORT\n        let pId = pChain.getBlockchainID()\n        let xId = avm.getBlockchainID()\n        let txId\n\n        if (sourceChain === 'X') {\n            let toAddress = this.platformHelper.getCurrentAddress()\n            let xChangeAddr = this.internalHelper.getCurrentAddress()\n            let fromAddrs = this.getDerivedAddresses()\n\n            let exportTx = await avm.buildExportTx(\n                this.utxoset,\n                amtFee,\n                pId,\n                [toAddress],\n                fromAddrs,\n                [xChangeAddr]\n            )\n            let tx = await this.sign<AVMUnsignedTx, AVMTx>(exportTx)\n            return avm.issueTx(tx)\n        } else if (sourceChain === 'P') {\n            let utxoSet = this.platformHelper.utxoSet as PlatformUTXOSet\n            let toAddress = this.externalHelper.getCurrentAddress()\n            let pChangeAddr = this.platformHelper.getCurrentAddress()\n            let fromAddrs = this.platformHelper.getAllDerivedAddresses()\n\n            let exportTx = await pChain.buildExportTx(\n                utxoSet,\n                amtFee,\n                xId,\n                [toAddress],\n                fromAddrs,\n                [pChangeAddr]\n            )\n\n            let tx = await this.sign<PlatformUnsignedTx, PlatformTx>(exportTx, false)\n            return pChain.issueTx(tx)\n        } else {\n            throw 'Invalid source chain.'\n        }\n    }\n\n    async importToPlatformChain(): Promise<string> {\n        // await this.platformHelper.findHdIndex();\n        const utxoSet = (await this.platformHelper.getAtomicUTXOs()) as PlatformUTXOSet\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        // let pAddrs = this.platformHelper.getAllDerivedAddresses()\n        // Owner addresses, the addresses we exported to\n        let pToAddr = this.platformHelper.getCurrentAddress()\n\n        let hrp = ava.getHRP()\n        let utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'P', addr))\n        // let fromAddrs = utxoAddrs\n        let ownerAddrs = utxoAddrs\n\n        const unsignedTx = await pChain.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            avm.getBlockchainID(),\n            [pToAddr],\n            [pToAddr],\n            [pToAddr],\n            undefined,\n            undefined\n        )\n        const tx = await this.sign<PlatformUnsignedTx, PlatformTx>(unsignedTx, false)\n\n        return pChain.issueTx(tx)\n    }\n\n    // TODO: Move to Core HD file\n    async importToXChain(sourceChain: ChainIdType): Promise<string> {\n        const utxoSet = (await this.externalHelper.getAtomicUTXOs()) as AVMUTXOSet\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        // let externalIndex = this.externalHelper.hdIndex\n        // let xAddrs = this.externalHelper.getAllDerivedAddresses()\n        let xToAddr = this.externalHelper.getCurrentAddress()\n        // let externalAddresses = this.externalHelper.getExtendedAddresses()\n        // let xAddrs = this.getDerivedAddresses()\n        // let xToAddr = this.externalHelper.getAllDerivedAddresses(externalIndex+10);\n\n        let hrp = ava.getHRP()\n        let utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'X', addr))\n\n        let fromAddrs = utxoAddrs\n        let ownerAddrs = utxoAddrs\n\n        let sourceChainId\n        if (sourceChain === 'P') {\n            sourceChainId = pChain.getBlockchainID()\n        } else {\n            sourceChainId = cChain.getBlockchainID()\n        }\n\n        // Owner addresses, the addresses we exported to\n        const unsignedTx = await avm.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            sourceChainId,\n            [xToAddr],\n            fromAddrs,\n            [xToAddr]\n        )\n\n        let tx = await this.sign<AVMUnsignedTx, AVMTx>(unsignedTx)\n\n        return avm.issueTx(tx)\n    }\n\n    async importToCChain(): Promise<string> {\n        console.error('Not implemented.')\n        return ''\n    }\n\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        // let keychain = this.platformHelper.getKeychain() as PlatformVMKeyChain;\n        let utxoSet: PlatformUTXOSet = this.platformHelper.utxoSet as PlatformUTXOSet\n        let pAddressStrings = this.platformHelper.getAllDerivedAddresses()\n        let stakeAmount = amt\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = this.getPlatformRewardAddress()\n        }\n\n        let stakeReturnAddr = this.getPlatformRewardAddress()\n\n        // For change address use first available on the platform chain\n        let changeAddress = this.platformHelper.getFirstAvailableAddress()\n        // Causes Ledger to crash because change and reward address are the same\n        // let changeAddress = this.platformHelper.getCurrentAddress()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddDelegatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings,\n            [changeAddress],\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress] // reward address\n        )\n\n        const tx = await this.sign<PlatformUnsignedTx, PlatformTx>(unsignedTx, false)\n\n        // Update UTXOS\n        setTimeout(async () => {\n            this.getUTXOs()\n        }, 3000)\n\n        return pChain.issueTx(tx)\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let utxoSet: PlatformUTXOSet = this.platformHelper.utxoSet as PlatformUTXOSet\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        let pAddressStrings = this.platformHelper.getAllDerivedAddresses()\n\n        let stakeAmount = amt\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = this.getPlatformRewardAddress()\n        }\n\n        // For change address use first available on the platform chain\n        let changeAddress = this.platformHelper.getFirstAvailableAddress()\n        // Causes Ledger to crash because change and reward address are the same\n        // let changeAddress = this.platformHelper.getCurrentAddress()\n\n        // Stake is always returned to address at index 0\n        let stakeReturnAddr = this.getPlatformRewardAddress()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddValidatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings, // from\n            [changeAddress], // change\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress],\n            delegationFee\n        )\n\n        // console.log(unsignedTx.serialize('display'));\n        // console.log(unsignedTx.toBuffer().toString('hex'))\n\n        let tx = await this.sign<PlatformUnsignedTx, PlatformTx>(unsignedTx, false)\n\n        // console.log(tx.toBuffer().toString('hex'));\n        // console.log((tx.serialize()))\n        // console.log((tx.serialize('display')))\n        // Update UTXOS\n        setTimeout(async () => {\n            this.getUTXOs()\n        }, 3000)\n        return pChain.issueTx(tx)\n    }\n\n    async signMessage(msgStr: string, address: string): Promise<string> {\n        let index = this.externalHelper.findAddressIndex(address)\n\n        if (index === null) throw 'Address not found.'\n\n        let pathStr = `0/${index}`\n        const addressPath = bippath.fromString(pathStr, false)\n        const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n\n        let digest = digestMessage(msgStr)\n        let digestBuff = Buffer.from(digest)\n        let digestHex = digestBuff.toString('hex')\n\n        store.commit('Ledger/openModal', {\n            title: `Sign Hash`,\n            info: digestHex.toUpperCase(),\n        })\n\n        try {\n            let sigMap = await this.app.signHash(accountPath, [addressPath], digestBuff)\n            store.commit('Ledger/closeModal')\n            let signed = sigMap.get(pathStr)\n            return bintools.cb58Encode(signed)\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            throw e\n        }\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        let tx = await this.buildCreateNftFamilyTx(name, symbol, groupNum)\n        let signed = await this.sign<AVMUnsignedTx, AVMTx>(tx)\n        return await avm.issueTx(signed)\n    }\n\n    async mintNft(mintUtxo: UTXO, payload: PayloadBase, quantity: number) {\n        let tx = await this.buildMintNftTx(\n            mintUtxo,\n            payload,\n            quantity,\n            this.getCurrentAddress(),\n            this.getChangeAddress()\n        )\n        let signed = await this.sign<AVMUnsignedTx, AVMTx>(tx)\n        return await avm.issueTx(signed)\n    }\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        console.error('Not available yet.')\n        return 'NOT AVAILABLE'\n    }\n}\n\nexport { LedgerWallet }\n","var isoLangs = {\n    ab: {\n        name: 'Abkhaz',\n        nativeName: 'аҧсуа',\n    },\n    aa: {\n        name: 'Afar',\n        nativeName: 'Afaraf',\n    },\n    af: {\n        name: 'Afrikaans',\n        nativeName: 'Afrikaans',\n    },\n    ak: {\n        name: 'Akan',\n        nativeName: 'Akan',\n    },\n    sq: {\n        name: 'Albanian',\n        nativeName: 'Shqip',\n    },\n    am: {\n        name: 'Amharic',\n        nativeName: 'አማርኛ',\n    },\n    ar: {\n        name: 'Arabic',\n        nativeName: 'العربية',\n    },\n    an: {\n        name: 'Aragonese',\n        nativeName: 'Aragonés',\n    },\n    hy: {\n        name: 'Armenian',\n        nativeName: 'Հայերեն',\n    },\n    as: {\n        name: 'Assamese',\n        nativeName: 'অসমীয়া',\n    },\n    av: {\n        name: 'Avaric',\n        nativeName: 'авар мацӀ, магӀарул мацӀ',\n    },\n    ae: {\n        name: 'Avestan',\n        nativeName: 'avesta',\n    },\n    ay: {\n        name: 'Aymara',\n        nativeName: 'aymar aru',\n    },\n    az: {\n        name: 'Azerbaijani',\n        nativeName: 'azərbaycan dili',\n    },\n    bm: {\n        name: 'Bambara',\n        nativeName: 'bamanankan',\n    },\n    ba: {\n        name: 'Bashkir',\n        nativeName: 'башҡорт теле',\n    },\n    eu: {\n        name: 'Basque',\n        nativeName: 'euskara, euskera',\n    },\n    be: {\n        name: 'Belarusian',\n        nativeName: 'Беларуская',\n    },\n    bn: {\n        name: 'Bengali',\n        nativeName: 'বাংলা',\n    },\n    bh: {\n        name: 'Bihari',\n        nativeName: 'भोजपुरी',\n    },\n    bi: {\n        name: 'Bislama',\n        nativeName: 'Bislama',\n    },\n    bs: {\n        name: 'Bosnian',\n        nativeName: 'bosanski jezik',\n    },\n    br: {\n        name: 'Breton',\n        nativeName: 'brezhoneg',\n    },\n    bg: {\n        name: 'Bulgarian',\n        nativeName: 'български език',\n    },\n    my: {\n        name: 'Burmese',\n        nativeName: 'ဗမာစာ',\n    },\n    ca: {\n        name: 'Catalan; Valencian',\n        nativeName: 'Català',\n    },\n    ch: {\n        name: 'Chamorro',\n        nativeName: 'Chamoru',\n    },\n    ce: {\n        name: 'Chechen',\n        nativeName: 'нохчийн мотт',\n    },\n    ny: {\n        name: 'Chichewa; Chewa; Nyanja',\n        nativeName: 'chiCheŵa, chinyanja',\n    },\n    cn: {\n        name: 'Chinese',\n        nativeName: '中文 (Zhōngwén), 汉语, 漢語',\n    },\n    zh_hans: {\n        name: 'Chinese (Simplified)',\n        nativeName: '汉语',\n    },\n    zh_hant: {\n        name: 'Chinese (Traditional)',\n        nativeName: '漢語',\n    },\n    cv: {\n        name: 'Chuvash',\n        nativeName: 'чӑваш чӗлхи',\n    },\n    kw: {\n        name: 'Cornish',\n        nativeName: 'Kernewek',\n    },\n    co: {\n        name: 'Corsican',\n        nativeName: 'corsu, lingua corsa',\n    },\n    cr: {\n        name: 'Cree',\n        nativeName: 'ᓀᐦᐃᔭᐍᐏᐣ',\n    },\n    hr: {\n        name: 'Croatian',\n        nativeName: 'hrvatski',\n    },\n    cs: {\n        name: 'Czech',\n        nativeName: 'česky, čeština',\n    },\n    da: {\n        name: 'Danish',\n        nativeName: 'dansk',\n    },\n    dv: {\n        name: 'Divehi; Dhivehi; Maldivian;',\n        nativeName: 'ދިވެހި',\n    },\n    nl: {\n        name: 'Dutch',\n        nativeName: 'Nederlands, Vlaams',\n    },\n    en: {\n        name: 'English',\n        nativeName: 'English',\n    },\n    eo: {\n        name: 'Esperanto',\n        nativeName: 'Esperanto',\n    },\n    et: {\n        name: 'Estonian',\n        nativeName: 'eesti, eesti keel',\n    },\n    ee: {\n        name: 'Ewe',\n        nativeName: 'Eʋegbe',\n    },\n    fo: {\n        name: 'Faroese',\n        nativeName: 'føroyskt',\n    },\n    fj: {\n        name: 'Fijian',\n        nativeName: 'vosa Vakaviti',\n    },\n    fi: {\n        name: 'Finnish',\n        nativeName: 'suomi, suomen kieli',\n    },\n    fr: {\n        name: 'French',\n        nativeName: 'Français',\n    },\n    ff: {\n        name: 'Fula; Fulah; Pulaar; Pular',\n        nativeName: 'Fulfulde, Pulaar, Pular',\n    },\n    gl: {\n        name: 'Galician',\n        nativeName: 'Galego',\n    },\n    ka: {\n        name: 'Georgian',\n        nativeName: 'ქართული',\n    },\n    de: {\n        name: 'German',\n        nativeName: 'Deutsch',\n    },\n    el: {\n        name: 'Greek, Modern',\n        nativeName: 'Ελληνικά',\n    },\n    gn: {\n        name: 'Guaraní',\n        nativeName: 'Avañeẽ',\n    },\n    gu: {\n        name: 'Gujarati',\n        nativeName: 'ગુજરાતી',\n    },\n    ht: {\n        name: 'Haitian; Haitian Creole',\n        nativeName: 'Kreyòl ayisyen',\n    },\n    ha: {\n        name: 'Hausa',\n        nativeName: 'Hausa, هَوُسَ',\n    },\n    he: {\n        name: 'Hebrew (modern)',\n        nativeName: 'עברית',\n    },\n    hz: {\n        name: 'Herero',\n        nativeName: 'Otjiherero',\n    },\n    hi: {\n        name: 'Hindi',\n        nativeName: 'हिन्दी, हिंदी',\n    },\n    ho: {\n        name: 'Hiri Motu',\n        nativeName: 'Hiri Motu',\n    },\n    hu: {\n        name: 'Hungarian',\n        nativeName: 'Magyar',\n    },\n    ia: {\n        name: 'Interlingua',\n        nativeName: 'Interlingua',\n    },\n    id: {\n        name: 'Indonesian',\n        nativeName: 'Bahasa Indonesia',\n    },\n    ie: {\n        name: 'Interlingue',\n        nativeName: 'Originally called Occidental; then Interlingue after WWII',\n    },\n    ga: {\n        name: 'Irish',\n        nativeName: 'Gaeilge',\n    },\n    ig: {\n        name: 'Igbo',\n        nativeName: 'Asụsụ Igbo',\n    },\n    ik: {\n        name: 'Inupiaq',\n        nativeName: 'Iñupiaq, Iñupiatun',\n    },\n    io: {\n        name: 'Ido',\n        nativeName: 'Ido',\n    },\n    is: {\n        name: 'Icelandic',\n        nativeName: 'Íslenska',\n    },\n    it: {\n        name: 'Italian',\n        nativeName: 'Italiano',\n    },\n    iu: {\n        name: 'Inuktitut',\n        nativeName: 'ᐃᓄᒃᑎᑐᑦ',\n    },\n    ja: {\n        name: 'Japanese',\n        nativeName: '日本語',\n    },\n    jv: {\n        name: 'Javanese',\n        nativeName: 'basa Jawa',\n    },\n    kl: {\n        name: 'Kalaallisut, Greenlandic',\n        nativeName: 'kalaallisut, kalaallit oqaasii',\n    },\n    kn: {\n        name: 'Kannada',\n        nativeName: 'ಕನ್ನಡ',\n    },\n    // \"kr\": {\n    //     \"name\": \"Kanuri\",\n    //     \"nativeName\": \"Kanuri\"\n    // },\n    ks: {\n        name: 'Kashmiri',\n        nativeName: 'कश्मीरी, كشميري‎',\n    },\n    kk: {\n        name: 'Kazakh',\n        nativeName: 'Қазақ тілі',\n    },\n    km: {\n        name: 'Khmer',\n        nativeName: 'ភាសាខ្មែរ',\n    },\n    ki: {\n        name: 'Kikuyu, Gikuyu',\n        nativeName: 'Gĩkũyũ',\n    },\n    rw: {\n        name: 'Kinyarwanda',\n        nativeName: 'Ikinyarwanda',\n    },\n    ky: {\n        name: 'Kirghiz, Kyrgyz',\n        nativeName: 'кыргыз тили',\n    },\n    kv: {\n        name: 'Komi',\n        nativeName: 'коми кыв',\n    },\n    kg: {\n        name: 'Kongo',\n        nativeName: 'KiKongo',\n    },\n    kr: {\n        name: 'Korean',\n        nativeName: '한국어',\n    },\n    ku: {\n        name: 'Kurdish',\n        nativeName: 'Kurdî, كوردی‎',\n    },\n    kj: {\n        name: 'Kwanyama, Kuanyama',\n        nativeName: 'Kuanyama',\n    },\n    la: {\n        name: 'Latin',\n        nativeName: 'latine, lingua latina',\n    },\n    lb: {\n        name: 'Luxembourgish, Letzeburgesch',\n        nativeName: 'Lëtzebuergesch',\n    },\n    lg: {\n        name: 'Luganda',\n        nativeName: 'Luganda',\n    },\n    li: {\n        name: 'Limburgish, Limburgan, Limburger',\n        nativeName: 'Limburgs',\n    },\n    ln: {\n        name: 'Lingala',\n        nativeName: 'Lingála',\n    },\n    lo: {\n        name: 'Lao',\n        nativeName: 'ພາສາລາວ',\n    },\n    lt: {\n        name: 'Lithuanian',\n        nativeName: 'lietuvių kalba',\n    },\n    lu: {\n        name: 'Luba-Katanga',\n        nativeName: '',\n    },\n    lv: {\n        name: 'Latvian',\n        nativeName: 'latviešu valoda',\n    },\n    gv: {\n        name: 'Manx',\n        nativeName: 'Gaelg, Gailck',\n    },\n    mk: {\n        name: 'Macedonian',\n        nativeName: 'македонски јазик',\n    },\n    mg: {\n        name: 'Malagasy',\n        nativeName: 'Malagasy fiteny',\n    },\n    ms: {\n        name: 'Malay',\n        nativeName: 'bahasa Melayu, بهاس ملايو‎',\n    },\n    ml: {\n        name: 'Malayalam',\n        nativeName: 'മലയാളം',\n    },\n    mt: {\n        name: 'Maltese',\n        nativeName: 'Malti',\n    },\n    mi: {\n        name: 'Māori',\n        nativeName: 'te reo Māori',\n    },\n    mr: {\n        name: 'Marathi (Marāṭhī)',\n        nativeName: 'मराठी',\n    },\n    mh: {\n        name: 'Marshallese',\n        nativeName: 'Kajin M̧ajeļ',\n    },\n    mn: {\n        name: 'Mongolian',\n        nativeName: 'монгол',\n    },\n    na: {\n        name: 'Nauru',\n        nativeName: 'Ekakairũ Naoero',\n    },\n    nv: {\n        name: 'Navajo, Navaho',\n        nativeName: 'Diné bizaad, Dinékʼehǰí',\n    },\n    nb: {\n        name: 'Norwegian Bokmål',\n        nativeName: 'Norsk bokmål',\n    },\n    nd: {\n        name: 'North Ndebele',\n        nativeName: 'isiNdebele',\n    },\n    ne: {\n        name: 'Nepali',\n        nativeName: 'नेपाली',\n    },\n    ng: {\n        name: 'Ndonga',\n        nativeName: 'Owambo',\n    },\n    nn: {\n        name: 'Norwegian Nynorsk',\n        nativeName: 'Norsk nynorsk',\n    },\n    no: {\n        name: 'Norwegian',\n        nativeName: 'Norsk',\n    },\n    ii: {\n        name: 'Nuosu',\n        nativeName: 'ꆈꌠ꒿ Nuosuhxop',\n    },\n    nr: {\n        name: 'South Ndebele',\n        nativeName: 'isiNdebele',\n    },\n    oc: {\n        name: 'Occitan',\n        nativeName: 'Occitan',\n    },\n    oj: {\n        name: 'Ojibwe, Ojibwa',\n        nativeName: 'ᐊᓂᔑᓈᐯᒧᐎᓐ',\n    },\n    cu: {\n        name: 'Old Church Slavonic, Church Slavic, Church Slavonic, Old Bulgarian, Old Slavonic',\n        nativeName: 'ѩзыкъ словѣньскъ',\n    },\n    om: {\n        name: 'Oromo',\n        nativeName: 'Afaan Oromoo',\n    },\n    or: {\n        name: 'Oriya',\n        nativeName: 'ଓଡ଼ିଆ',\n    },\n    os: {\n        name: 'Ossetian, Ossetic',\n        nativeName: 'ирон æвзаг',\n    },\n    pa: {\n        name: 'Panjabi, Punjabi',\n        nativeName: 'ਪੰਜਾਬੀ, پنجابی‎',\n    },\n    pi: {\n        name: 'Pāli',\n        nativeName: 'पाऴि',\n    },\n    fa: {\n        name: 'Persian',\n        nativeName: 'فارسی',\n    },\n    pl: {\n        name: 'Polish',\n        nativeName: 'polski',\n    },\n    ps: {\n        name: 'Pashto, Pushto',\n        nativeName: 'پښتو',\n    },\n    pt: {\n        name: 'Portuguese',\n        nativeName: 'Português',\n    },\n    qu: {\n        name: 'Quechua',\n        nativeName: 'Runa Simi, Kichwa',\n    },\n    rm: {\n        name: 'Romansh',\n        nativeName: 'rumantsch grischun',\n    },\n    rn: {\n        name: 'Kirundi',\n        nativeName: 'kiRundi',\n    },\n    ro: {\n        name: 'Romanian, Moldavian, Moldovan',\n        nativeName: 'română',\n    },\n    ru: {\n        name: 'Russian',\n        nativeName: 'русский язык',\n    },\n    sa: {\n        name: 'Sanskrit (Saṁskṛta)',\n        nativeName: 'संस्कृतम्',\n    },\n    sc: {\n        name: 'Sardinian',\n        nativeName: 'sardu',\n    },\n    sd: {\n        name: 'Sindhi',\n        nativeName: 'सिन्धी, سنڌي، سندھی‎',\n    },\n    se: {\n        name: 'Northern Sami',\n        nativeName: 'Davvisámegiella',\n    },\n    sm: {\n        name: 'Samoan',\n        nativeName: 'gagana faa Samoa',\n    },\n    sg: {\n        name: 'Sango',\n        nativeName: 'yângâ tî sängö',\n    },\n    sr: {\n        name: 'Serbian',\n        nativeName: 'српски језик',\n    },\n    gd: {\n        name: 'Scottish Gaelic; Gaelic',\n        nativeName: 'Gàidhlig',\n    },\n    sn: {\n        name: 'Shona',\n        nativeName: 'chiShona',\n    },\n    si: {\n        name: 'Sinhala, Sinhalese',\n        nativeName: 'සිංහල',\n    },\n    sk: {\n        name: 'Slovak',\n        nativeName: 'slovenčina',\n    },\n    sl: {\n        name: 'Slovene',\n        nativeName: 'slovenščina',\n    },\n    so: {\n        name: 'Somali',\n        nativeName: 'Soomaaliga, af Soomaali',\n    },\n    st: {\n        name: 'Southern Sotho',\n        nativeName: 'Sesotho',\n    },\n    es: {\n        name: 'Spanish; Castilian',\n        nativeName: 'Español',\n    },\n    su: {\n        name: 'Sundanese',\n        nativeName: 'Basa Sunda',\n    },\n    sw: {\n        name: 'Swahili',\n        nativeName: 'Kiswahili',\n    },\n    ss: {\n        name: 'Swati',\n        nativeName: 'SiSwati',\n    },\n    sv: {\n        name: 'Swedish',\n        nativeName: 'svenska',\n    },\n    ta: {\n        name: 'Tamil',\n        nativeName: 'தமிழ்',\n    },\n    te: {\n        name: 'Telugu',\n        nativeName: 'తెలుగు',\n    },\n    tg: {\n        name: 'Tajik',\n        nativeName: 'тоҷикӣ, toğikī, تاجیکی‎',\n    },\n    th: {\n        name: 'Thai',\n        nativeName: 'ไทย',\n    },\n    ti: {\n        name: 'Tigrinya',\n        nativeName: 'ትግርኛ',\n    },\n    bo: {\n        name: 'Tibetan Standard, Tibetan, Central',\n        nativeName: 'བོད་ཡིག',\n    },\n    tk: {\n        name: 'Turkmen',\n        nativeName: 'Türkmen, Түркмен',\n    },\n    tl: {\n        name: 'Tagalog',\n        nativeName: 'Wikang Tagalog, ᜏᜒᜃᜅ᜔ ᜆᜄᜎᜓᜄ᜔',\n    },\n    tn: {\n        name: 'Tswana',\n        nativeName: 'Setswana',\n    },\n    to: {\n        name: 'Tonga (Tonga Islands)',\n        nativeName: 'faka Tonga',\n    },\n    tr: {\n        name: 'Turkish',\n        nativeName: 'Türkçe',\n    },\n    ts: {\n        name: 'Tsonga',\n        nativeName: 'Xitsonga',\n    },\n    tt: {\n        name: 'Tatar',\n        nativeName: 'татарча, tatarça, تاتارچا‎',\n    },\n    tw: {\n        name: 'Twi',\n        nativeName: 'Twi',\n    },\n    ty: {\n        name: 'Tahitian',\n        nativeName: 'Reo Tahiti',\n    },\n    ug: {\n        name: 'Uighur, Uyghur',\n        nativeName: 'Uyƣurqə, ئۇيغۇرچە‎',\n    },\n    uk: {\n        name: 'Ukrainian',\n        nativeName: 'українська',\n    },\n    ur: {\n        name: 'Urdu',\n        nativeName: 'اردو',\n    },\n    uz: {\n        name: 'Uzbek',\n        nativeName: 'zbek, Ўзбек, أۇزبېك‎',\n    },\n    ve: {\n        name: 'Venda',\n        nativeName: 'Tshivenḓa',\n    },\n    vn: {\n        name: 'Vietnamese',\n        nativeName: 'Tiếng Việt',\n    },\n    vo: {\n        name: 'Volapük',\n        nativeName: 'Volapük',\n    },\n    wa: {\n        name: 'Walloon',\n        nativeName: 'Walon',\n    },\n    cy: {\n        name: 'Welsh',\n        nativeName: 'Cymraeg',\n    },\n    wo: {\n        name: 'Wolof',\n        nativeName: 'Wollof',\n    },\n    fy: {\n        name: 'Western Frisian',\n        nativeName: 'Frysk',\n    },\n    xh: {\n        name: 'Xhosa',\n        nativeName: 'isiXhosa',\n    },\n    yi: {\n        name: 'Yiddish',\n        nativeName: 'ייִדיש',\n    },\n    yo: {\n        name: 'Yoruba',\n        nativeName: 'Yorùbá',\n    },\n    za: {\n        name: 'Zhuang, Chuang',\n        nativeName: 'Saɯ cueŋƅ, Saw cuengh',\n    },\n}\n\nexport default isoLangs\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { digestMessage } from '@/helpers/helper'\nimport { WalletNameType } from '@/store/types'\nimport { Buffer } from 'avalanche'\nimport {\n    KeyPair as AVMKeyPair,\n    KeyChain as AVMKeyChain,\n    UTXOSet as AVMUTXOSet,\n    UTXO,\n    UnsignedTx,\n} from 'avalanche/dist/apis/avm'\nimport {\n    KeyPair as PlatformKeyPair,\n    KeyChain as PlatformKeyChain,\n    UTXOSet as PlatformUTXOSet,\n    UTXOSet,\n} from 'avalanche/dist/apis/platformvm'\nimport { KeyChain, KeyChain as EVMKeyChain, UTXOSet as EVMUTXOSet } from 'avalanche/dist/apis/evm'\n\nimport { StandardTx, StandardUnsignedTx, UTXOResponse } from 'avalanche/dist/common'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\nimport BN from 'bn.js'\nimport {\n    buildExportTransaction,\n    buildUnsignedTransaction,\n    buildCreateNftFamilyTx,\n    buildMintNftTx,\n} from '../TxHelper'\nimport { AvaWalletCore, ChainAlias, UnsafeWallet } from './IAvaHdWallet'\nimport { UTXO as PlatformUTXO } from 'avalanche/dist/apis/platformvm/utxos'\nimport { privateToAddress } from 'ethereumjs-util'\nimport { web3 } from '@/evm'\nimport { ChainIdType } from '@/constants'\nimport { Tx as AVMTx, UnsignedTx as AVMUnsignedTx } from 'avalanche/dist/apis/avm/tx'\nimport {\n    Tx as PlatformTx,\n    UnsignedTx as PlatformUnsignedTx,\n} from 'avalanche/dist/apis/platformvm/tx'\nimport { UnsignedTx as EVMUnsignedTx } from 'avalanche/dist/apis/evm/tx'\nvar uniqid = require('uniqid')\n\nclass SingletonWallet implements AvaWalletCore, UnsafeWallet {\n    id: string\n    keyChain: AVMKeyChain\n    keyPair: AVMKeyPair\n    utxoset: AVMUTXOSet\n\n    platformKeyChain: PlatformKeyChain\n    platformKeyPair: PlatformKeyPair\n    platformUtxoset: PlatformUTXOSet\n\n    chainId: string\n    chainIdP: string\n\n    key: string\n\n    stakeAmount: BN\n\n    type: WalletNameType\n\n    ethKey: string\n    ethKeyBech: string\n    ethKeyChain: EVMKeyChain\n    ethAddress: string\n    ethAddressBech: string\n    ethBalance: BN\n\n    isFetchUtxos: boolean\n    isInit: boolean\n    constructor(pk: string) {\n        this.id = uniqid()\n        this.key = pk\n\n        this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID()\n        this.chainIdP = pChain.getBlockchainAlias() || pChain.getBlockchainID()\n\n        let hrp = ava.getHRP()\n\n        this.keyChain = new AVMKeyChain(hrp, this.chainId)\n        this.utxoset = new AVMUTXOSet()\n        this.keyPair = this.keyChain.importKey(pk)\n\n        this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP)\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.platformKeyPair = this.platformKeyChain.importKey(pk)\n\n        this.stakeAmount = new BN(0)\n\n        // Derive EVM key and address\n        let pkBuf = bintools.cb58Decode(pk.split('-')[1])\n        let pkHex = pkBuf.toString('hex')\n        this.ethKey = pkHex\n        // @ts-ignore\n        this.ethAddress = privateToAddress(pkBuf).toString('hex')\n        this.ethBalance = new BN(0)\n        this.ethAddressBech = ''\n\n        let cPrivKey = `PrivateKey-` + bintools.cb58Encode(Buffer.from(pkBuf))\n        this.ethKeyBech = cPrivKey\n        let cKeyChain = new KeyChain(ava.getHRP(), 'C')\n        this.ethKeyChain = cKeyChain\n\n        let cKeypair = cKeyChain.importKey(cPrivKey)\n        this.ethAddressBech = cKeypair.getAddressString()\n\n        this.isFetchUtxos = false\n\n        this.type = 'singleton'\n        this.isInit = true\n    }\n\n    async chainTransfer(\n        amt: BN,\n        sourceChain: string,\n        destinationChain: ChainIdType\n    ): Promise<string> {\n        let fee = avm.getTxFee()\n        let amtFee = amt.add(fee)\n        if (destinationChain === 'C') {\n            // C Chain imports/exports do not have a fee\n            amtFee = amt\n        }\n        // EXPORT\n        let pId = pChain.getBlockchainID()\n        let xId = avm.getBlockchainID()\n        let txId\n        if (sourceChain === 'X') {\n            let destinationAddr\n            if (destinationChain === 'P') {\n                destinationAddr = this.getCurrentPlatformAddress()\n            } else {\n                // C Chain\n                // todo: replace with shared wallet class method\n                destinationAddr = this.ethAddressBech\n            }\n\n            let fromAddresses = this.getAllAddressesX()\n            let changeAddress = this.getChangeAddress()\n            let utxos = this.getUTXOSet()\n            let exportTx = (await buildExportTransaction(\n                sourceChain,\n                destinationChain,\n                utxos,\n                fromAddresses,\n                destinationAddr,\n                amtFee,\n                changeAddress\n            )) as AVMUnsignedTx\n\n            let tx = (await this.sign<AVMUnsignedTx, AVMTx>(exportTx)) as AVMTx\n            return avm.issueTx(tx)\n        } else if (sourceChain === 'P') {\n            let destinationAddr = this.getCurrentAddress()\n            let fromAddresses = this.getAllAddressesP()\n\n            let changeAddress = this.getCurrentPlatformAddress()\n            let utxos = this.getPlatformUTXOSet()\n\n            let exportTx = (await buildExportTransaction(\n                sourceChain,\n                destinationChain,\n                utxos,\n                fromAddresses,\n                destinationAddr,\n                amtFee,\n                changeAddress\n            )) as PlatformUnsignedTx\n\n            let tx = (await this.sign<PlatformUnsignedTx, PlatformTx>(\n                exportTx,\n                false\n            )) as PlatformTx\n\n            return pChain.issueTx(tx)\n        } else if (sourceChain === 'C') {\n            let destinationAddr = this.getCurrentAddress()\n            let fromAddresses = [this.ethAddress]\n            let changeAddress = this.ethAddressBech\n            let utxos = this.getPlatformUTXOSet()\n\n            let exportTx = (await buildExportTransaction(\n                sourceChain,\n                destinationChain,\n                utxos,\n                fromAddresses,\n                destinationAddr,\n                amtFee,\n                changeAddress,\n                this.ethAddressBech\n            )) as EVMUnsignedTx\n\n            let tx = await exportTx.sign(this.ethKeyChain)\n            return cChain.issueTx(tx)\n        } else {\n            throw 'Invalid source chain.'\n        }\n    }\n\n    getChangeAddress(): string {\n        return this.getCurrentAddress()\n    }\n\n    getCurrentAddress(): string {\n        return this.keyPair.getAddressString()\n    }\n\n    getDerivedAddresses(): string[] {\n        let addr = this.getCurrentAddress()\n        return [addr]\n    }\n\n    getAllDerivedExternalAddresses(): string[] {\n        return this.getDerivedAddresses()\n    }\n\n    getExtendedPlatformAddresses(): string[] {\n        let addr = this.platformKeyPair.getAddressString()\n        return [addr]\n    }\n\n    getHistoryAddresses(): string[] {\n        let addr = this.getCurrentAddress()\n        return [addr]\n    }\n\n    getPlatformRewardAddress(): string {\n        return this.getCurrentPlatformAddress()\n    }\n\n    getCurrentPlatformAddress(): string {\n        return this.platformKeyPair.getAddressString()\n    }\n\n    getBaseAddress(): string {\n        return this.getCurrentAddress()\n    }\n\n    async getStake(): Promise<BN> {\n        let addr = this.getCurrentPlatformAddress()\n        let res = await pChain.getStake([addr])\n\n        this.stakeAmount = res\n        return res\n    }\n\n    getUTXOSet(): AVMUTXOSet {\n        return this.utxoset\n    }\n\n    getPlatformUTXOSet(): PlatformUTXOSet {\n        return this.platformUtxoset\n    }\n    // TODO: Move to shared class\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    // TODO: Move to shared class\n    async getEthBalance() {\n        let bal = await web3.eth.getBalance(this.ethAddress)\n        this.ethBalance = new BN(bal)\n        return this.ethBalance\n    }\n\n    // TODO: Move to shared class\n    async getAtomicUTXOs(chainId: ChainAlias) {\n        // console.log(addrs);\n        if (chainId === 'P') {\n            let result: PlatformUTXOSet = (\n                await pChain.getUTXOs(this.getExtendedPlatformAddresses(), avm.getBlockchainID())\n            ).utxos\n            return result\n        } else {\n            let result: AVMUTXOSet = (\n                await avm.getUTXOs(this.getDerivedAddresses(), pChain.getBlockchainID())\n            ).utxos\n\n            let resultC: AVMUTXOSet = (\n                await avm.getUTXOs(this.getDerivedAddresses(), cChain.getBlockchainID())\n            ).utxos\n\n            return result.merge(resultC)\n        }\n    }\n\n    async updateUtxos(\n        // TODO, type\n        chainId: ChainAlias\n    ): Promise<AVMUTXOSet | PlatformUTXOSet> {\n        let result: AVMUTXOSet | PlatformUTXOSet\n\n        if (chainId === 'X') {\n            result = await this.avmGetAllUTXOsForAddresses([this.getCurrentAddress()])\n            this.utxoset = result // we can use local copy of utxos as cache for some functions\n        } else {\n            result = await this.platformGetAllUTXOsForAddresses([this.getCurrentPlatformAddress()])\n            this.platformUtxoset = result\n        }\n\n        return result\n    }\n\n    async getUTXOs(): Promise<void> {\n        this.isFetchUtxos = true\n        let setInternal = (await this.updateUtxos('X')) as AVMUTXOSet\n        // TODO\n        // platform utxos are updated but not returned by function\n        let setPlatform = (await this.updateUtxos('P')) as PlatformUTXOSet\n\n        await this.getStake()\n        await this.getEthBalance()\n\n        this.isFetchUtxos = false\n\n        return\n    }\n\n    async platformGetAllUTXOsForAddresses(\n        addrs: string[],\n        endIndex: any = undefined\n    ): Promise<PlatformUTXOSet> {\n        let response\n        if (!endIndex) {\n            response = await pChain.getUTXOs(addrs)\n        } else {\n            response = await pChain.getUTXOs(addrs, undefined, 0, endIndex)\n        }\n\n        let utxoSet = response.utxos\n        let nextEndIndex = response.endIndex\n        let len = response.numFetched\n\n        if (len >= 1024) {\n            let subUtxos = await this.platformGetAllUTXOsForAddresses(addrs, nextEndIndex)\n            return utxoSet.merge(subUtxos)\n        }\n\n        return utxoSet\n    }\n\n    async avmGetAllUTXOsForAddresses(\n        addrs: string[],\n        endIndex: any = undefined\n    ): Promise<AVMUTXOSet> {\n        let response\n        if (!endIndex) {\n            response = await avm.getUTXOs(addrs)\n        } else {\n            response = await avm.getUTXOs(addrs, undefined, 0, endIndex)\n        }\n\n        let utxoSet = response.utxos\n        let utxos = utxoSet.getAllUTXOs()\n        let nextEndIndex = response.endIndex\n        let len = response.numFetched\n\n        if (len >= 1024) {\n            let subUtxos = await this.avmGetAllUTXOsForAddresses(addrs, nextEndIndex)\n            return utxoSet.merge(subUtxos)\n        }\n        return utxoSet\n    }\n\n    async importToPlatformChain(): Promise<string> {\n        // await this.platformHelper.findHdIndex();\n        const utxoSet = (await this.getAtomicUTXOs('P')) as PlatformUTXOSet\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let keyChain = this.platformKeyChain as PlatformKeyChain\n        let pAddrs = keyChain.getAddressStrings()\n        // Owner addresses, the addresses we exported to\n        let pToAddr = this.getCurrentPlatformAddress()\n\n        const unsignedTx = await pChain.buildImportTx(\n            utxoSet,\n            pAddrs,\n            avm.getBlockchainID(),\n            [pToAddr],\n            [pToAddr],\n            [pToAddr],\n            undefined,\n            undefined\n        )\n        const tx = unsignedTx.sign(keyChain)\n\n        return pChain.issueTx(tx)\n    }\n\n    async importToXChain(sourceChain: ChainIdType): Promise<string> {\n        const utxoSet = (await this.getAtomicUTXOs('X')) as AVMUTXOSet\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let keyChain = this.keyChain as AVMKeyChain\n        let xAddrs = keyChain.getAddressStrings()\n        let xToAddr = this.getCurrentAddress()\n\n        let sourceChainId\n        if (sourceChain === 'P') {\n            sourceChainId = pChain.getBlockchainID()\n        } else {\n            sourceChainId = cChain.getBlockchainID()\n        }\n        // Owner addresses, the addresses we exported to\n        const unsignedTx = await avm.buildImportTx(\n            utxoSet,\n            xAddrs,\n            sourceChainId,\n            [xToAddr],\n            xAddrs,\n            [xToAddr]\n        )\n        const tx = unsignedTx.sign(keyChain)\n\n        return avm.issueTx(tx)\n    }\n\n    async importToCChain(): Promise<string> {\n        const utxoResponse: UTXOResponse = await cChain.getUTXOs(\n            this.ethAddressBech,\n            avm.getBlockchainID()\n        )\n        const utxoSet: EVMUTXOSet = utxoResponse.utxos\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let toAddress = '0x' + this.ethAddress\n        let ownerAddresses = [this.ethAddressBech]\n        let fromAddresses = ownerAddresses\n        let sourceChain = avm.getBlockchainID()\n\n        const unsignedTx = await cChain.buildImportTx(\n            utxoSet,\n            toAddress,\n            ownerAddresses,\n            sourceChain,\n            fromAddresses\n        )\n        let keyChain = this.ethKeyChain\n        const tx = unsignedTx.sign(keyChain)\n        let id = await cChain.issueTx(tx)\n\n        return id\n    }\n\n    async buildUnsignedTransaction(orders: (ITransaction | UTXO)[], addr: string, memo?: Buffer) {\n        const changeAddress = this.getChangeAddress()\n        const derivedAddresses = this.getDerivedAddresses()\n        const utxoset = this.getUTXOSet() as AVMUTXOSet\n\n        return buildUnsignedTransaction(\n            orders,\n            addr,\n            derivedAddresses,\n            utxoset,\n            changeAddress,\n            memo\n        )\n    }\n\n    async issueBatchTx(\n        orders: (UTXO | ITransaction)[],\n        addr: string,\n        memo: Buffer | undefined\n    ): Promise<string> {\n        let unsignedTx = await this.buildUnsignedTransaction(orders, addr, memo)\n        const tx = unsignedTx.sign(this.keyChain as AVMKeyChain)\n        const txId: string = await avm.issueTx(tx)\n        return txId\n    }\n\n    onnetworkchange(): void {\n        let hrp = ava.getHRP()\n\n        this.keyChain = new AVMKeyChain(hrp, this.chainId)\n        this.utxoset = new AVMUTXOSet()\n        this.keyPair = this.keyChain.importKey(this.key)\n\n        this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP)\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.platformKeyPair = this.platformKeyChain.importKey(this.key)\n\n        // Update EVM values\n        this.ethKeyChain = new EVMKeyChain(ava.getHRP(), 'C')\n        let cKeypair = this.ethKeyChain.importKey(this.ethKeyBech)\n        this.ethAddressBech = cKeypair.getAddressString()\n        this.ethBalance = new BN(0)\n\n        this.getUTXOs()\n    }\n\n    async sign<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx\n    >(unsignedTx: UnsignedTx, isAVM = true): Promise<SignedTx> {\n        if (isAVM) {\n            return (unsignedTx as AVMUnsignedTx).sign(this.keyChain) as SignedTx\n        } else {\n            return (unsignedTx as PlatformUnsignedTx).sign(this.platformKeyChain) as SignedTx\n        }\n    }\n\n    async signMessage(msgStr: string): Promise<string> {\n        let digest = digestMessage(msgStr)\n\n        let digestHex = digest.toString('hex')\n        let digestBuff = Buffer.from(digestHex, 'hex')\n        let signed = this.keyPair.sign(digestBuff)\n\n        return bintools.cb58Encode(signed)\n    }\n\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let keychain = this.platformKeyChain as PlatformKeyChain\n        let utxoSet: PlatformUTXOSet = this.platformUtxoset as PlatformUTXOSet\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        let pAddressStrings = keychain.getAddressStrings()\n        let stakeAmount = amt\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = this.getPlatformRewardAddress()\n        }\n\n        // For change address use first available on the platform chain\n        let changeAddr = this.getCurrentPlatformAddress()\n\n        // Stake is always returned to address at index 0\n        let stakeReturnAddr = this.getPlatformRewardAddress()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddDelegatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings,\n            [changeAddr],\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress] // reward address\n        )\n        const tx = unsignedTx.sign(keychain)\n        // Update UTXOS\n        setTimeout(async () => {\n            this.getUTXOs()\n        }, 3000)\n\n        return pChain.issueTx(tx)\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number = 0,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let keychain = this.platformKeyChain as PlatformKeyChain\n        let utxoSet: PlatformUTXOSet = this.platformUtxoset as PlatformUTXOSet\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        let pAddressStrings = keychain.getAddressStrings()\n\n        let stakeAmount = amt\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = this.getPlatformRewardAddress()\n        }\n\n        // For change address use first available on the platform chain\n        let changeAddress = this.getCurrentPlatformAddress()\n\n        // Stake is always returned to address at index 0\n        let stakeReturnAddr = this.getPlatformRewardAddress()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddValidatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings, // from\n            [changeAddress], // change\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress],\n            delegationFee\n        )\n        let tx = unsignedTx.sign(keychain)\n\n        // Update UTXOS\n        setTimeout(async () => {\n            this.getUTXOs()\n        }, 3000)\n        return pChain.issueTx(tx)\n    }\n\n    async buildCreateNftFamilyTx(name: string, symbol: string, groupNum: number) {\n        let fromAddresses = this.getDerivedAddresses()\n        let changeAddress = this.getChangeAddress()\n\n        let minterAddress = this.getCurrentAddress()\n\n        let unsignedTx = await buildCreateNftFamilyTx(\n            name,\n            symbol,\n            groupNum,\n            fromAddresses,\n            minterAddress,\n            changeAddress,\n            this.utxoset\n        )\n        return unsignedTx\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        let tx = await this.buildCreateNftFamilyTx(name, symbol, groupNum)\n        let signed = (await this.sign<AVMUnsignedTx, AVMTx>(tx)) as AVMTx\n        return await avm.issueTx(signed)\n    }\n\n    async buildMintNftTx(\n        mintUtxo: UTXO,\n        payload: PayloadBase,\n        quantity: number,\n        ownerAddress: string,\n        changeAddress: string\n    ): Promise<UnsignedTx> {\n        let sourceAddresses = this.getDerivedAddresses()\n\n        let mintTx = buildMintNftTx(\n            mintUtxo,\n            payload,\n            quantity,\n            ownerAddress,\n            changeAddress,\n            sourceAddresses,\n            this.utxoset\n        )\n\n        return mintTx\n    }\n\n    async mintNft(mintUtxo: UTXO, payload: PayloadBase, quantity: number) {\n        let tx = await this.buildMintNftTx(\n            mintUtxo,\n            payload,\n            quantity,\n            this.getCurrentAddress(),\n            this.getChangeAddress()\n        )\n        let signed = await this.sign<AVMUnsignedTx, AVMTx>(tx)\n        return await avm.issueTx(signed)\n    }\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        let receiver = to\n        let txAmount = amount\n        let fromAddr = this.ethAddress\n\n        let account = web3.eth.accounts.privateKeyToAccount(this.ethKey)\n\n        const txConfig = {\n            from: fromAddr,\n            gasPrice: gasPrice,\n            gas: gasLimit,\n            to: receiver,\n            value: txAmount.toString(), // in wei\n            data: '',\n        }\n\n        let signedTx = await account.signTransaction(txConfig)\n        let err,\n            receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction as string)\n\n        if (err) {\n            console.error(err)\n            throw err\n        }\n\n        return receipt.transactionHash\n    }\n\n    getAllAddressesX() {\n        return [this.getCurrentAddress()]\n    }\n\n    getAllAddressesP() {\n        return [this.getCurrentPlatformAddress()]\n    }\n}\n\nexport { SingletonWallet }\n","class AvaNftFamily {\n    id: string\n    name: string\n    symbol: string\n\n    constructor(id: string, name: string, symbol: string) {\n        this.id = id\n        this.name = name\n        this.symbol = symbol\n    }\n}\n\nexport { AvaNftFamily }\n","import store from '@/store/index'\nimport { ava } from '@/AVA'\n\nimport {\n    KeyChain as AVMKeyChain,\n    KeyPair as AVMKeyPair,\n    NFTTransferOutput,\n    UTXO,\n} from 'avalanche/dist/apis/avm'\n\nimport { Defaults, getPreferredHRP, ONEAVAX, PayloadBase, PayloadTypes } from 'avalanche/dist/utils'\nimport { BN } from 'avalanche/dist'\nimport Big from 'big.js'\n\nimport { Buffer } from 'avalanche'\nimport createHash from 'create-hash'\n\nfunction getAssetIcon(id: string) {\n    let url = '/question-solid.svg'\n    let AVA = store.getters['Assets/AssetAVA']\n\n    if (!AVA) return url\n    if (id === AVA.id) {\n        return '/ava_letter_icon.png'\n    }\n    return url\n}\n\nfunction bnToBig(val: BN, denomination = 0): Big {\n    return new Big(val.toString()).div(Math.pow(10, denomination))\n}\n\nfunction keyToKeypair(key: string, chainID: string = 'X'): AVMKeyPair {\n    let hrp = getPreferredHRP(ava.getNetworkID())\n    let keychain = new AVMKeyChain(hrp, chainID)\n    return keychain.importKey(key)\n}\n\nfunction calculateStakingReward(amount: BN, duration: number, currentSupply: BN): BN {\n    let networkID = ava.getNetworkID()\n\n    //@ts-ignore\n    let defValues = Defaults.network[networkID]\n\n    if (!defValues) {\n        console.error('Network default values not found.')\n        return new BN(0)\n    }\n    defValues = defValues.P\n\n    let maxConsumption: number = defValues.maxConsumption\n    let minConsumption: number = defValues.minConsumption\n    let diffConsumption = maxConsumption - minConsumption\n    let maxSupply: BN = defValues.maxSupply\n    let maxStakingDuration: BN = defValues.maxStakingDuration\n    let remainingSupply = maxSupply.sub(currentSupply)\n\n    let amtBig = Big(amount.div(ONEAVAX).toString())\n    let currentSupplyBig = Big(currentSupply.div(ONEAVAX).toString())\n    let remainingSupplyBig = Big(remainingSupply.div(ONEAVAX).toString())\n    let portionOfExistingSupplyBig = amtBig.div(currentSupplyBig)\n\n    let portionOfStakingDuration = duration / maxStakingDuration.toNumber()\n    let mintingRate = minConsumption + diffConsumption * portionOfStakingDuration\n\n    let rewardBig: Big = remainingSupplyBig.times(portionOfExistingSupplyBig)\n    rewardBig = rewardBig.times(Big(mintingRate * portionOfStakingDuration))\n\n    let rewardStr = rewardBig.times(Math.pow(10, 9)).toFixed(0)\n    let rewardBN = new BN(rewardStr)\n\n    return rewardBN\n}\n\nfunction digestMessage(msgStr: string) {\n    let mBuf = Buffer.from(msgStr, 'utf8')\n    let msgSize = Buffer.alloc(4)\n    msgSize.writeUInt32BE(mBuf.length, 0)\n    let msgBuf = Buffer.from(`\\x1AAvalanche Signed Message:\\n${msgSize}${msgStr}`, 'utf8')\n    return createHash('sha256').update(msgBuf).digest()\n}\n\nlet payloadtypes = PayloadTypes.getInstance()\n\nfunction getPayloadFromUTXO(utxo: UTXO): PayloadBase {\n    let out = utxo.getOutput() as NFTTransferOutput\n    let payload = out.getPayloadBuffer()\n\n    let typeId = payloadtypes.getTypeID(payload)\n    let pl: Buffer = payloadtypes.getContent(payload)\n    let payloadbase: PayloadBase = payloadtypes.select(typeId, pl)\n\n    return payloadbase\n}\n\nexport {\n    getAssetIcon,\n    keyToKeypair,\n    calculateStakingReward,\n    bnToBig,\n    digestMessage,\n    getPayloadFromUTXO,\n}\n","// Manages BigNumber and Ava conversion and arithmetic\nimport BN from 'bn.js'\nimport Big from 'big.js'\n\nclass AvaAsset {\n    id: string\n    name: string\n    symbol: string\n    denomination: number\n    amount: BN\n    amountLocked: BN\n    // AVAX P chain, Wallet Staking\n    amountExtra: BN\n    private readonly pow: Big\n    constructor(id: string, name: string, symbol: string, denomination: number) {\n        this.id = id\n        this.name = name\n        this.symbol = symbol\n        this.denomination = denomination\n        this.amount = new BN(0, 10)\n        this.amountLocked = new BN(0, 10)\n        this.amountExtra = new BN(0, 10)\n        this.pow = Big(10).pow(denomination)\n    }\n\n    addBalance(val: BN): void {\n        this.amount = this.amount.add(val)\n    }\n\n    addBalanceLocked(val: BN): void {\n        this.amountLocked = this.amountLocked.add(val)\n    }\n\n    addExtra(val: BN): void {\n        this.amountExtra = this.amountExtra.add(val)\n    }\n\n    resetBalance() {\n        this.amount = new BN(0, 10)\n        this.amountLocked = new BN(0, 10)\n        this.amountExtra = new BN(0, 10)\n    }\n\n    getAmount(locked: boolean = false): Big {\n        if (!locked) {\n            return Big(this.amount.toString(10)).div(this.pow)\n        } else {\n            return Big(this.amountLocked.toString(10)).div(this.pow)\n        }\n    }\n\n    getAmountBN(locked: boolean = false): BN {\n        if (!locked) {\n            return this.amount\n        } else {\n            return this.amountLocked\n        }\n    }\n\n    getTotalAmount(): BN {\n        return this.amount.add(this.amountLocked).add(this.amountExtra)\n    }\n\n    toStringTotal(): string {\n        let big: Big = Big(this.getTotalAmount().toString(10)).div(this.pow)\n        return big.toLocaleString(this.denomination)\n    }\n\n    toString() {\n        let big: Big = Big(this.amount.toString(10)).div(this.pow)\n        return big.toLocaleString(this.denomination)\n        // if(big.lt(Big('0.001'))){\n        //     return big.toLocaleString(this.denomination);\n        // }else{\n        //     let min = Math.min(this.denomination, 2);\n        //     return big.toLocaleString(min);\n        // }\n    }\n}\n\nexport default AvaAsset\n","// A simple wrapper thar combines avalanche.js, bip39 and HDWallet\n\nimport {\n    KeyPair as AVMKeyPair,\n    KeyChain as AVMKeyChain,\n    UTXOSet as AVMUTXOSet,\n    TransferableInput,\n    TransferableOutput,\n    BaseTx,\n    UnsignedTx as AVMUnsignedTx,\n    Tx as AVMTx,\n    UTXO as AVMUTXO,\n    AssetAmountDestination,\n    UTXOSet,\n} from 'avalanche/dist/apis/avm'\n\nimport { web3 } from '@/evm'\nimport { privateToAddress } from 'ethereumjs-util'\n\nimport {\n    KeyChain as PlatformVMKeyChain,\n    UTXOSet as PlatformUTXOSet,\n    UnsignedTx as PlatformUnsignedTx,\n    UTXO as PlatformUTXO,\n    Tx as PlatformTx,\n} from 'avalanche/dist/apis/platformvm'\n\nimport {\n    UTXOSet as EVMUTXOSet,\n    KeyChain as EVMKeyChain,\n    UnsignedTx as EVMUnsignedTx,\n} from 'avalanche/dist/apis/evm'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\n\nimport * as bip39 from 'bip39'\nimport { BN, Buffer } from 'avalanche'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { IAvaHdWallet, IIndexKeyCache } from '@/js/wallets/IAvaHdWallet'\nimport HDKey from 'hdkey'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { HdHelper } from '@/js/HdHelper'\nimport { KeyPair as PlatformVMKeyPair } from 'avalanche/dist/apis/platformvm'\nimport createHash from 'create-hash'\nimport { HdWalletCore } from '@/js/wallets/HdWalletCore'\nimport { WalletNameType } from '@/store/types'\nimport { StandardTx, StandardUnsignedTx, UTXOResponse } from 'avalanche/dist/common'\nimport { digestMessage } from '@/helpers/helper'\nimport { buildExportTransaction } from '@/js/TxHelper'\nimport { ChainIdType } from '@/constants'\nimport { KeyChain } from 'avalanche/dist/apis/evm'\n\n// HD WALLET\n// Accounts are not used and the account index is fixed to 0\n// m / purpose' / coin_type' / account' / change / address_index\n\nconst AVA_TOKEN_INDEX: string = '9000'\nexport const AVA_ACCOUNT_PATH: string = `m/44'/${AVA_TOKEN_INDEX}'/0'` // Change and index left out\nconst ETH_ACCOUNT_PATH: string = `m/44'/60'/0'`\n\nconst INDEX_RANGE: number = 20 // a gap of at least 20 indexes is needed to claim an index unused\nconst SCAN_SIZE: number = 70 // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE // How many items are actually scanned\n\n// Possible indexes for each request is\n// SCAN_SIZE - INDEX_RANGE\n\nexport default class AvaHdWallet extends HdWalletCore implements IAvaHdWallet {\n    seed: string\n    hdKey: HDKey\n    mnemonic: string\n    isLoading: boolean\n    type: WalletNameType\n    ethKey: string\n    ethKeyBech: string\n    ethKeyChain: EVMKeyChain\n    ethAddress: string\n    ethAddressBech: string\n    ethBalance: BN\n\n    // TODO : Move to hd core class\n    onnetworkchange() {\n        super.onnetworkchange()\n\n        // Update EVM values\n        this.ethKeyChain = new EVMKeyChain(ava.getHRP(), 'C')\n        let cKeypair = this.ethKeyChain.importKey(this.ethKeyBech)\n        this.ethAddressBech = cKeypair.getAddressString()\n        this.ethBalance = new BN(0)\n    }\n\n    // The master key from avalanche.js\n    constructor(mnemonic: string) {\n        let seed: globalThis.Buffer = bip39.mnemonicToSeedSync(mnemonic)\n        let masterHdKey: HDKey = HDKey.fromMasterSeed(seed)\n        let accountHdKey = masterHdKey.derive(AVA_ACCOUNT_PATH)\n\n        super(accountHdKey, false)\n\n        // Derive EVM key and address\n        let ethAccountKey = masterHdKey.derive(ETH_ACCOUNT_PATH + '/0/0')\n        let ethPrivateKey = ethAccountKey.privateKey\n        this.ethKey = ethPrivateKey.toString('hex')\n        this.ethAddress = privateToAddress(ethPrivateKey).toString('hex')\n        this.ethBalance = new BN(0)\n\n        let cPrivKey = `PrivateKey-` + bintools.cb58Encode(Buffer.from(ethPrivateKey))\n        this.ethKeyBech = cPrivKey\n\n        let cKeyChain = new KeyChain(ava.getHRP(), 'C')\n        this.ethKeyChain = cKeyChain\n\n        let cKeypair = cKeyChain.importKey(cPrivKey)\n        this.ethAddressBech = cKeypair.getAddressString()\n\n        this.type = 'mnemonic'\n        this.seed = seed.toString('hex')\n        this.hdKey = masterHdKey\n        this.mnemonic = mnemonic\n        this.isLoading = false\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    async getEthBalance() {\n        let bal = await web3.eth.getBalance(this.ethAddress)\n        this.ethBalance = new BN(bal)\n        return this.ethBalance\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        let receiver = to\n        let txAmount = amount\n        let fromAddr = this.ethAddress\n\n        let account = web3.eth.accounts.privateKeyToAccount(this.ethKey)\n\n        const txConfig = {\n            from: fromAddr,\n            gasPrice: gasPrice,\n            gas: gasLimit,\n            to: receiver,\n            value: txAmount.toString(), // in wei\n            data: '',\n        }\n\n        let signedTx = await account.signTransaction(txConfig)\n        let err,\n            receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction as string)\n\n        if (err) {\n            console.error(err)\n            throw err\n        }\n\n        return receipt.transactionHash\n    }\n\n    async getUTXOs(): Promise<void> {\n        // TODO: Move to shared file\n        this.isFetchUtxos = true\n        // If we are waiting for helpers to initialize delay the call\n        let isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n        if (!isInit) {\n            setTimeout(() => {\n                this.getUTXOs()\n            }, 1000)\n            // console.info('HD Not ready try again in 1 sec..')\n            return\n        }\n\n        super.getUTXOs()\n        this.getEthBalance()\n        return\n    }\n\n    getCurrentKey(): AVMKeyPair {\n        return this.externalHelper.getCurrentKey() as AVMKeyPair\n    }\n\n    getAllDerivedKeys(isInternal = false): AVMKeyPair[] | PlatformVMKeyPair[] {\n        if (isInternal) {\n            return this.internalHelper.getAllDerivedKeys()\n        } else {\n            return this.externalHelper.getAllDerivedKeys()\n        }\n    }\n\n    getMnemonic(): string {\n        return this.mnemonic\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number = 0,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let keychain = this.platformHelper.getKeychain() as PlatformVMKeyChain\n        let utxoSet: PlatformUTXOSet = this.platformHelper.utxoSet as PlatformUTXOSet\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        let pAddressStrings = keychain.getAddressStrings()\n\n        let stakeAmount = amt\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = this.getPlatformRewardAddress()\n        }\n\n        // For change address use first available on the platform chain\n        let changeAddress = this.platformHelper.getFirstAvailableAddress()\n\n        // Stake is always returned to address at index 0\n        let stakeReturnAddr = this.getPlatformRewardAddress()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddValidatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings, // from\n            [changeAddress], // change\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress],\n            delegationFee\n        )\n        let tx = unsignedTx.sign(keychain)\n\n        // Update UTXOS\n        setTimeout(async () => {\n            this.getUTXOs()\n        }, 3000)\n        return pChain.issueTx(tx)\n    }\n\n    // Delegates AVAX to the given node ID\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let keychain = this.platformHelper.getKeychain() as PlatformVMKeyChain\n        let utxoSet: PlatformUTXOSet = this.platformHelper.utxoSet as PlatformUTXOSet\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        let pAddressStrings = keychain.getAddressStrings()\n        let stakeAmount = amt\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = this.getPlatformRewardAddress()\n        }\n\n        // For change address use first available on the platform chain\n        let changeAddr = this.platformHelper.getFirstAvailableAddress()\n\n        // Stake is always returned to address at index 0\n        let stakeReturnAddr = this.getPlatformRewardAddress()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddDelegatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings,\n            [changeAddr],\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress] // reward address\n        )\n        const tx = unsignedTx.sign(keychain)\n        // Update UTXOS\n        setTimeout(async () => {\n            this.getUTXOs()\n        }, 3000)\n\n        return pChain.issueTx(tx)\n    }\n\n    async chainTransfer(\n        amt: BN,\n        sourceChain: ChainIdType,\n        destinationChain: ChainIdType\n    ): Promise<string> {\n        let fee = avm.getTxFee()\n        let amtFee = amt.add(fee)\n\n        if (destinationChain === 'C') {\n            // C Chain imports/exports do not have a fee\n            amtFee = amt\n        }\n\n        // Get from addresses\n        if (sourceChain === 'X') {\n            let destinationAddr\n            if (destinationChain === 'P') {\n                destinationAddr = this.getCurrentPlatformAddress()\n            } else {\n                // C Chain\n                // todo: replace with shared wallet class method\n                destinationAddr = this.ethAddressBech\n            }\n\n            let fromAddresses = this.getAllAddressesX()\n            let changeAddress = this.getChangeAddress()\n            let utxos = this.getUTXOSet()\n            let exportTx = (await buildExportTransaction(\n                sourceChain,\n                destinationChain,\n                utxos,\n                fromAddresses,\n                destinationAddr,\n                amtFee,\n                changeAddress\n            )) as AVMUnsignedTx\n\n            let tx = await this.sign<AVMUnsignedTx, AVMTx>(exportTx)\n            return avm.issueTx(tx)\n        } else if (sourceChain === 'P') {\n            let destinationAddr = this.getCurrentAddress()\n            let fromAddresses = this.getAllAddressesP()\n\n            let changeAddress = this.getCurrentPlatformAddress()\n            let utxos = this.getPlatformUTXOSet()\n\n            let exportTx = (await buildExportTransaction(\n                sourceChain,\n                destinationChain,\n                utxos,\n                fromAddresses,\n                destinationAddr,\n                amtFee,\n                changeAddress\n            )) as PlatformUnsignedTx\n\n            let tx = await this.sign<PlatformUnsignedTx, PlatformTx>(exportTx, false)\n\n            return pChain.issueTx(tx)\n        } else if (sourceChain === 'C') {\n            let destinationAddr = this.getCurrentAddress()\n            let fromAddresses = [this.ethAddress]\n            let changeAddress = this.ethAddressBech\n            let utxos = this.getPlatformUTXOSet()\n\n            let exportTx = (await buildExportTransaction(\n                sourceChain,\n                destinationChain,\n                utxos,\n                fromAddresses,\n                destinationAddr,\n                amtFee,\n                changeAddress,\n                this.ethAddressBech\n            )) as EVMUnsignedTx\n\n            let tx = await exportTx.sign(this.ethKeyChain)\n            return cChain.issueTx(tx)\n        } else {\n            throw 'Invalid source chain.'\n        }\n    }\n\n    // TODO: Move to Core HD file\n    async importToCChain(): Promise<string> {\n        const utxoResponse: UTXOResponse = await cChain.getUTXOs(\n            this.ethAddressBech,\n            avm.getBlockchainID()\n        )\n        const utxoSet: EVMUTXOSet = utxoResponse.utxos\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let toAddress = '0x' + this.ethAddress\n        let ownerAddresses = [this.ethAddressBech]\n        let fromAddresses = ownerAddresses\n        let sourceChain = avm.getBlockchainID()\n\n        const unsignedTx = await cChain.buildImportTx(\n            utxoSet,\n            toAddress,\n            ownerAddresses,\n            sourceChain,\n            fromAddresses\n        )\n        let keyChain = this.ethKeyChain\n        const tx = unsignedTx.sign(keyChain)\n        let id = await cChain.issueTx(tx)\n\n        return id\n    }\n\n    // TODO: Move to Core HD file\n    async importToPlatformChain(): Promise<string> {\n        // await this.platformHelper.findHdIndex();\n        const utxoSet = (await this.platformHelper.getAtomicUTXOs()) as PlatformUTXOSet\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let keyChain = this.platformHelper.getKeychain() as PlatformVMKeyChain\n        let pAddrs = keyChain.getAddressStrings()\n        // Owner addresses, the addresses we exported to\n        let pToAddr = this.platformHelper.getCurrentAddress()\n\n        let hrp = ava.getHRP()\n        let utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'P', addr))\n        let fromAddrs = utxoAddrs\n        let ownerAddrs = utxoAddrs\n\n        const unsignedTx = await pChain.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            avm.getBlockchainID(),\n            [pToAddr],\n            [pToAddr],\n            [pToAddr],\n            undefined,\n            undefined\n        )\n        const tx = unsignedTx.sign(keyChain)\n\n        return pChain.issueTx(tx)\n    }\n\n    // TODO: Move to Core HD file\n    async importToXChain(sourceChain: ChainIdType) {\n        const utxoSet = (await this.externalHelper.getAtomicUTXOs()) as AVMUTXOSet\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let keyChain = this.getKeyChain() as AVMKeyChain\n        // let xAddrs = keyChain.getAddressStrings()\n        let xToAddr = this.externalHelper.getCurrentAddress()\n\n        let hrp = ava.getHRP()\n        let utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'X', addr))\n\n        let fromAddrs = utxoAddrs\n        let ownerAddrs = utxoAddrs\n\n        let sourceChainId\n        if (sourceChain === 'P') {\n            sourceChainId = pChain.getBlockchainID()\n        } else {\n            sourceChainId = cChain.getBlockchainID()\n        }\n        // Owner addresses, the addresses we exported to\n        const unsignedTx = await avm.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            sourceChainId,\n            [xToAddr],\n            fromAddrs,\n            [xToAddr]\n        )\n        const tx = unsignedTx.sign(keyChain)\n\n        return avm.issueTx(tx)\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: Buffer | undefined\n    ): Promise<string> {\n        let unsignedTx = await this.buildUnsignedTransaction(orders, addr, memo)\n        let keychain = this.getKeyChain()\n\n        const tx = unsignedTx.sign(keychain)\n        const txId: string = await avm.issueTx(tx)\n\n        // // TODO: This might not be necessary anymore\n        // setTimeout(async () => {\n        //     // Find the new HD index\n        //     this.internalHelper.findHdIndex()\n        //     this.externalHelper.findHdIndex()\n        //     this.platformHelper.findHdIndex()\n        // }, 2000)\n\n        return txId\n    }\n\n    // returns a keychain that has all the derived private/public keys for X chain\n    getKeyChain(): AVMKeyChain {\n        let internal = this.internalHelper.getAllDerivedKeys() as AVMKeyPair[]\n        let external = this.externalHelper.getAllDerivedKeys() as AVMKeyPair[]\n\n        let allKeys = internal.concat(external)\n        let keychain: AVMKeyChain = new AVMKeyChain(\n            getPreferredHRP(ava.getNetworkID()),\n            this.chainId\n        )\n\n        for (var i = 0; i < allKeys.length; i++) {\n            keychain.addKey(allKeys[i])\n        }\n        return keychain\n    }\n\n    getExtendedKeyChain() {\n        let internal = this.internalHelper.getAllDerivedKeys() as AVMKeyPair[]\n        let external = this.externalHelper.getAllDerivedKeys() as AVMKeyPair[]\n\n        let allKeys = internal.concat(external)\n        let keychain: AVMKeyChain = new AVMKeyChain(\n            getPreferredHRP(ava.getNetworkID()),\n            this.chainId\n        )\n\n        for (var i = 0; i < allKeys.length; i++) {\n            keychain.addKey(allKeys[i])\n        }\n        return keychain\n    }\n\n    async sign<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx\n    >(unsignedTx: UnsignedTx, isAVM: boolean = true): Promise<SignedTx> {\n        let keychain = this.getKeyChain()\n        let keychainP = this.platformHelper.getKeychain() as PlatformVMKeyChain\n\n        if (isAVM) {\n            const tx = (unsignedTx as AVMUnsignedTx).sign(keychain)\n            return tx as SignedTx\n        } else {\n            const tx = (unsignedTx as PlatformUnsignedTx).sign(keychainP)\n            return tx as SignedTx\n        }\n    }\n\n    async signMessage(msgStr: string, address: string): Promise<string> {\n        let index = this.externalHelper.findAddressIndex(address)\n\n        if (index === null) throw 'Address not found.'\n\n        let key = this.externalHelper.getKeyForIndex(index) as AVMKeyPair\n        let digest = digestMessage(msgStr)\n\n        // Convert to the other Buffer and sign\n        let digestHex = digest.toString('hex')\n        let digestBuff = Buffer.from(digestHex, 'hex')\n        let signed = key.sign(digestBuff)\n\n        return bintools.cb58Encode(signed)\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        let tx = await this.buildCreateNftFamilyTx(name, symbol, groupNum)\n        let signed = await this.sign<AVMUnsignedTx, AVMTx>(tx)\n        return await avm.issueTx(signed)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        let tx = await this.buildMintNftTx(\n            mintUtxo,\n            payload,\n            quantity,\n            this.getCurrentAddress(),\n            this.getChangeAddress()\n        )\n        let signed = await this.sign<AVMUnsignedTx, AVMTx>(tx)\n        let txId = await avm.issueTx(signed)\n        return txId\n    }\n}\n"],"sourceRoot":""}